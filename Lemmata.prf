(Lemmata
 (lemma_1 0
  (lemma_1-1 nil 3834042957
   ("" (skos 1 s0 s1 p alpha j)
    (("" (flatten 1)
      (("" (label "tran" -1) (("" (for-alpha :lazy? nil) nil nil)) nil)) nil))
    nil)
   ((Winner const-decl "bool" Lemmata nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (action type-decl nil actions nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil))
   shostak))
 (lemma_2 0
  (lemma_2-1 nil 3834043013
   ("" (skos 1 s0 s1 proc alpha j)
    (("" (flatten 1)
      (("" (label "tran" -1) (("" (for-alpha :lazy? nil) nil nil)) nil)) nil))
    nil)
   ((Competitor const-decl "bool" Lemmata nil)
    (CheckVictim const-decl "bool" Lemmata nil)
    (CheckFlag const-decl "bool" Lemmata nil)
    (Winner const-decl "bool" Lemmata nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (action type-decl nil actions nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil))
   shostak))
 (lemma_3 0
  (lemma_3-1 nil 3839771083
   ("" (skos 1 s0 s1 alpha p)
    (("" (flatten) (("" (for-alpha :lazy? nil) nil nil)) nil)) nil)
   ((action? nonempty-type-eq-decl nil actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (external adt-def-decl "boolean" actions nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (Effect const-decl "cState" FilterLock nil)
    (transition const-decl "bool" IOA nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (/= const-decl "boolean" notequal nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (lemma_4 0
  (lemma_4-1 nil 3846230230
   ("" (skeep)
    (("" (split)
      (("1" (lemma card_1_has_1)
        (("1" (inst -1 S)
          (("1" (notice -1)
            (("1" (skeep) (("1" (inst?) (("1" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (lemma card_bij)
          (("2" (inst -1 1 S)
            (("2" (replace -4)
              (("2" (flatten)
                (("2" (skeep)
                  (("2" (expand "bijective?")
                    (("2" (flatten)
                      (("2" (expand "injective?")
                        (("2"
                          (case "NOT (forall (P,Q:bool) : (P => Q) IFF (NOT Q => NOT P))")
                          (("1" (hide-all-but 1)
                            (("1" (grind) nil nil)) nil)
                           ("2" (expand "member")
                            (("2" (inst -2 p q)
                              (("2"
                                (inst -1 "f(p)=f(q)" "p=q")
                                (("2"
                                  (replace -2)
                                  (("2"
                                    (flatten)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (card_1_has_1 formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (card_bij formula-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (S skolem-const-decl "finite_set[PROC]" Lemmata nil)
    (p skolem-const-decl "PROC" Lemmata nil)
    (q skolem-const-decl "PROC" Lemmata nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (injective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (lemma_5 0
  (lemma_5-1 nil 3846230762
   ("" (skeep)
    (("" (split)
      (("1" (lemma card_2_has_2)
        (("1" (inst -1 S)
          (("1" (notice -1)
            (("1" (skeep)
              (("1" (inst?)
                (("1" (inst 2 y) (("1" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand "member")
          (("2" (lemma card_bij)
            (("2" (inst -1 2 S)
              (("2" (replace -5)
                (("2" (flatten)
                  (("2" (skeep)
                    (("2" (expand "bijective?")
                      (("2" (flatten)
                        (("2"
                          (case "NOT (forall (P,Q:bool) : (P => Q) IFF (NOT Q => NOT P)) ")
                          (("1" (hide-all-but 1)
                            (("1" (grind) nil nil)) nil)
                           ("2" (expand "injective?")
                            (("2" (copy -2)
                              (("2"
                                (copy -1)
                                (("2"
                                  (move-to-front -4)
                                  (("2"
                                    (inst -1 p q)
                                    (("2"
                                      (inst -2 q r)
                                      (("2"
                                        (inst -3 p r)
                                        (("2"
                                          (copy -4)
                                          (("2"
                                            (copy -1)
                                            (("2"
                                              (move-to-front -6)
                                              (("2"
                                                (inst
                                                 -1
                                                 "f(p)=f(q)"
                                                 "p=q")
                                                (("2"
                                                  (inst
                                                   -2
                                                   "f(q)=f(r)"
                                                   "q=r")
                                                  (("2"
                                                    (inst
                                                     -3
                                                     "f(p)=f(r)"
                                                     "p=r")
                                                    (("2"
                                                      (replace -4)
                                                      (("2"
                                                        (replace -5)
                                                        (("2"
                                                          (replace -6)
                                                          (("2"
                                                            (flatten)
                                                            (("2"
                                                              (replace
                                                               1)
                                                              (("2"
                                                                (replace
                                                                 4)
                                                                (("2"
                                                                  (replace
                                                                   7)
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (card_2_has_2 formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (bijective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (r skolem-const-decl "PROC" Lemmata nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (q skolem-const-decl "PROC" Lemmata nil)
    (p skolem-const-decl "PROC" Lemmata nil)
    (S skolem-const-decl "finite_set[PROC]" Lemmata nil)
    (injective? const-decl "bool" functions nil)
    (card_bij formula-decl nil finite_sets nil))
   shostak))
 (lemma_6_TCC1 0
  (FullCard_TCC1-1 nil 3839779295
   ("" (expand "is_finite")
    (("" (inst 1 THREADS id)
      (("" (expand "injective?")
        (("" (skos 1 x y)
          (("" (flatten) (("" (expand id) (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (< const-decl "bool" reals nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil))
   nil (lemma_6 subtype "sets[PROC].fullset" "finite_set[PROC]")))
 (lemma_6 0
  (lemma_6-1 nil 3843968379
   ("" (lemma card_bij)
    (("" (inst -1 THREADS "fullset[PROC]")
      (("" (flatten)
        (("" (split -1)
          (("1" (replace -1) (("1" (propax) nil nil)) nil)
           ("2" (delete 1)
            (("2" (split -1)
              (("1" (propax) nil nil)
               ("2" (inst 1 "id")
                (("2" (expand "bijective?")
                  (("2" (split)
                    (("1" (expand "injective?")
                      (("1" (skeep)
                        (("1" (expand "id") (("1" (propax) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "surjective?")
                      (("2" (skeep)
                        (("2" (inst 1 y)
                          (("1" (expand "id") (("1" (propax) nil nil))
                            nil)
                           ("2" (expand "fullset")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (fullset const-decl "set" sets nil)
    (surjective? const-decl "bool" functions nil)
    (y skolem-const-decl "below[THREADS]" Lemmata nil)
    (injective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil)
    (card_bij formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (PROC nonempty-type-eq-decl nil PROC nil))
   shostak))
 (inv_14 0
  (inv_14-1 nil 3833900936
   ("" (inv-setup)
    (("1" (install-rewrites "Lemmata")
      (("1" (conc-rewrite)
        (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (install-rewrites "Lemmata")
      (("2" (assert (ind-hyp concl))
        (("2" (skeep)
          (("2" (inst?)
            (("2" (case "proc(alpha)=p")
              (("1" (for-alpha :lazy? nil) nil nil) ("2" (for-alpha :lazy? nil) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (/= const-decl "boolean" notequal nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (empty? const-decl "bool" sets nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (member const-decl "bool" sets nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (action_lock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (Effect const-decl "cState" FilterLock nil)
    (transition const-decl "bool" IOA nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (PositiveI const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_15 0
  (inv_15-1 nil 3839518137
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand CSI)
          (("1" (skos 1 p) (("1" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (expand "CSI")
      (("2" (skos concl p)
        (("2" (inst ind-hyp p)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil) nil nil) ("2" (for-alpha :lazy? nil) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (CSI const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_16 0
  (inv_16-1 nil 3839504492
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand IIsOne)
          (("1" (skeep) (("1" (inst?) (("1" (flatten) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "IIsOne")
      (("2" (skos concl p)
        (("2" (inst ind-hyp p)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil) nil nil) ("2" (for-alpha :lazy? nil) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (IIsOne const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_17 0
  (inv_17-1 nil 3839752235
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "LevelValue")
          (("1" (skeep)
            (("1" (inst?) (("1" (flatten) (("1" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "LevelValue")
      (("2" (skos concl p)
        (("2" (inst ind-hyp p)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil) nil nil) ("2" (for-alpha :lazy? nil) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (LevelValue const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_18 0
  (inv_18-1 nil 3839751577
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "LevelRange")
          (("1" (skeep)
            (("1" (inst?)
              (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "LevelRange")
      (("2" (skos concl p)
        (("2" (inst ind-hyp p)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil)
              (("1" (inv-apply inv_16 s0)
                (("1" (expand "IIsOne")
                  (("1" (inst?)
                    (("1" (notice inv_16)
                      (("1" (reset-facts)
                        (("1"
                          (in-fact "s0`level(p)=0 OR s0`level(p)=1")
                          (("1" (split fact-1)
                            (("1" (flatten concl)
                              (("1"
                                (delete 1)
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (flatten concl)
                              (("2"
                                (delete 2)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("2" (split ind-hyp)
                (("1" (flatten concl)
                  (("1" (delete 1) (("1" (grind 2) nil nil)) nil)) nil)
                 ("2" (inv-apply inv_17 s0)
                  (("2" (expand "LevelValue")
                    (("2" (inst?)
                      (("2" (notice -1)
                        (("2" (hide-all-but (-1 -2))
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (IIsOne const-decl "bool" Lemmata nil)
    (TRUE const-decl "bool" booleans nil)
    (inv_16 formula-decl nil Lemmata nil)
    (inv_17 formula-decl nil Lemmata nil)
    (LevelValue const-decl "bool" Lemmata nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (LevelRange const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_19 0
  (inv_19-1 nil 3843967910
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "QQnotIn8")
          (("1" (skeep)
            (("1" (inst?)
              (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "QQnotIn8")
      (("2" (skos concl p)
        (("2" (case "proc(alpha)=p")
          (("1" (inst ind-hyp p) (("1" (for-alpha :lazy? nil) nil nil)) nil)
           ("2" (inst ind-hyp p) (("2" (for-alpha :lazy? nil) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (member const-decl "bool" sets nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (QQnotIn8 const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_20 0
  (inv_20-1 nil 3839777156
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "CAndS")
          (("1" (skeep)
            (("1" (inst?) (("1" (flatten) (("1" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "CAndS")
      (("2" (skos concl p q)
        (("2" (inst ind-hyp p q)
          (("2" (case "proc(alpha)=p OR proc(alpha)=q")
            (("1" (split -1)
              (("1" (for-alpha :lazy? nil) nil nil) ("2" (for-alpha :lazy? nil) nil nil))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (/= const-decl "boolean" notequal nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (empty? const-decl "bool" sets nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (add const-decl "(nonempty?)" sets nil)
    (remove const-decl "set" sets nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (action_lock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (Effect const-decl "cState" FilterLock nil)
    (transition const-decl "bool" IOA nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (fullset const-decl "set" sets nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (CAndS const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_21 0
  (inv_21-1 nil 3841125169
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "SComplementOfC")
          (("1" (skeep)
            (("1" (inst?)
              (("1" (flatten)
                (("1" (replace -4)
                  (("1" (replace -5)
                    (("1" (rewrite "complement_fullset") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "SComplementOfC")
      (("2" (skos concl p)
        (("2" (inst ind-hyp p)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil)
              (("1" (replace eff concl)
                (("1" (replace -1)
                  (("1" (beta concl)
                    (("1" (rewrite "remove_as_difference" 1)
                      (("1" (rewrite "difference_intersection" 1)
                        (("1" (rewrite "demorgan2" 1)
                          (("1" (rewrite "complement_complement" 1)
                            (("1" (rewrite "add_as_union" 1)
                              (("1"
                                (rewrite "complement_fullset" 1)
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("2" (replace eff concl)
                (("2" (replace -1)
                  (("2" (beta concl)
                    (("2" (rewrite "remove_as_difference" 1)
                      (("2" (rewrite "difference_intersection" 1)
                        (("2" (rewrite "demorgan2" 1)
                          (("2" (rewrite "complement_complement" 1)
                            (("2" (rewrite "add_as_union" 1)
                              (("2"
                                (rewrite "complement_fullset" 1)
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("3" (replace -1)
                (("3" (replace -6 concl)
                  (("3" (beta concl)
                    (("3" (rewrite "remove_as_difference" 1)
                      (("3" (rewrite "difference_intersection" 1)
                        (("3" (rewrite "demorgan2" 1)
                          (("3" (rewrite "complement_complement" 1)
                            (("3" (rewrite "add_as_union" 1)
                              (("3"
                                (replace ind-hyp concl)
                                (("3" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("4" (replace -1)
                (("4" (replace -6 concl)
                  (("4" (beta concl)
                    (("4" (rewrite "complement_fullset" 1) nil nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("5" (replace -1)
                (("5" (replace -6 concl)
                  (("5" (beta concl)
                    (("5" (rewrite "complement_fullset" 1) nil nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("6" (replace -6 concl)
                (("6" (replace -1)
                  (("6" (beta concl)
                    (("6" (rewrite "remove_as_difference" 1)
                      (("6" (rewrite "difference_intersection" 1)
                        (("6" (rewrite "demorgan2" 1)
                          (("6" (rewrite "complement_complement" 1)
                            (("6" (rewrite "add_as_union" 1)
                              (("6"
                                (rewrite "complement_fullset" 1)
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (remove_as_difference formula-decl nil sets_lemmas nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (complement const-decl "set" sets nil)
    (demorgan2 formula-decl nil sets_lemmas nil)
    (emptyset const-decl "set" sets nil)
    (add_as_union formula-decl nil sets_lemmas nil)
    (nonempty_finite_union2 application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (complement_complement formula-decl nil sets_lemmas nil)
    (difference_intersection formula-decl nil sets_lemmas nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (finite_difference application-judgement "finite_set[PROC]"
     FilterLock nil)
    (finite_intersection2 application-judgement "finite_set[PROC]"
     FilterLock nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (complement_fullset formula-decl nil sets_lemmas nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (SComplementOfC const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_22 0
  (inv_22-1 nil 3841130525
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "BoundedCCardinality")
          (("1" (skeep)
            (("1" (inst?)
              (("1" (flatten)
                (("1" (replace -4)
                  (("1" (lemma lemma_6)
                    (("1" (replace -1 1) (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "BoundedCCardinality")
      (("2" (skos concl p)
        (("2" (inst ind-hyp p)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil)
              (("1" (replace -1)
                (("1" (lemma lemma_6)
                  (("1" (replace -6 concl)
                    (("1" (beta concl)
                      (("1" (lemma card_remove)
                        (("1" (inst -1 "fullset" "proc(alpha)")
                          (("1" (expand "fullset" -1 3)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("2" (replace -1)
                (("2" (lemma lemma_6)
                  (("2" (replace -6 concl)
                    (("2" (beta concl)
                      (("2" (lemma card_remove)
                        (("2" (inst -1 "fullset" "proc(alpha)")
                          (("2" (expand "fullset" -1 3)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("3" (inv-apply inv_19 s0)
                (("3" (expand "QQnotIn8")
                  (("3" (inst inv_19 p)
                    (("3" (notice inv_19)
                      (("3" (inv-apply inv_20 s0)
                        (("3" (expand "CAndS")
                          (("3" (inst inv_20 p "s0`qq(p)")
                            (("3" (replace inv_19 inv_20)
                              (("3"
                                (flatten inv_20)
                                (("3"
                                  (delete inv_19)
                                  (("3"
                                    (with-labels
                                     (lemma card_remove)
                                     (("card_rem")))
                                    (("3"
                                      (inst -1 "s0`C(p)" "s0`qq(p)")
                                      (("3"
                                        (assert inv_20)
                                        (("3"
                                          (replace inv_20 card_rem)
                                          (("3"
                                            (lemma lemma_6)
                                            (("3" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("4" (replace -1)
                (("4" (replace -6 concl)
                  (("4" (beta concl)
                    (("4" (lemma lemma_6) (("4" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("5" (replace -1)
                (("5" (replace -6 concl)
                  (("5" (beta concl)
                    (("5" (lemma lemma_6) (("5" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("6" (replace -1)
                (("6" (lemma lemma_6)
                  (("6" (lemma card_remove)
                    (("6" (inst -1 "fullset" "proc(alpha)")
                      (("6" (expand "fullset" -1 3)
                        (("6" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (fullset const-decl "set" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (QQnotIn8 const-decl "bool" Lemmata nil)
    (CAndS const-decl "bool" Lemmata nil)
    (inv_20 formula-decl nil Lemmata nil)
    (inv_19 formula-decl nil Lemmata nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lemma_6 formula-decl nil Lemmata nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (BoundedCCardinality const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_23 0
  (inv_23-1 nil 3845209312
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "CAndSSize")
          (("1" (skeep)
            (("1" (inst?)
              (("1" (flatten)
                (("1" (replace -4)
                  (("1" (replace -5)
                    (("1" (lemma lemma_6)
                      (("1" (lemma card_emptyset)
                        (("1" (split 1)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "CAndSSize")
      (("2" (skos concl p _)
        (("2" (case "proc(alpha)=p")
          (("1" (copy ind-hyp)
            (("1" (inst ind-hyp p _)
              (("1" (for-alpha :lazy? nil)
                (("1" (replace eff concl)
                  (("1" (beta concl)
                    (("1" (skos concl n)
                      (("1" (inst ind-hyp n)
                        (("1" (lemma card_add)
                          (("1" (inst -1 "emptyset" "proc(alpha)")
                            (("1" (expand "emptyset" -1 3)
                              (("1"
                                (lemma card_emptyset)
                                (("1"
                                  (replace -1 -2)
                                  (("1"
                                    (assert -2)
                                    (("1"
                                      (lemma card_remove)
                                      (("1"
                                        (inst -1 "fullset" _)
                                        (("1"
                                          (inst -1 "proc(alpha)")
                                          (("1"
                                            (expand "fullset" -1 3)
                                            (("1"
                                              (lemma lemma_6)
                                              (("1"
                                                (replace -1 -2)
                                                (("1"
                                                  (grind 1)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (inst 1 THREADS id)
                                          (("2" (grind 1) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("2" (replace eff concl)
                  (("2" (beta concl)
                    (("2" (skos concl n)
                      (("2" (inst ind-hyp n)
                        (("2" (lemma card_add)
                          (("2" (inst -1 "emptyset" "proc(alpha)")
                            (("2" (expand "emptyset" -1 3)
                              (("2"
                                (lemma card_emptyset)
                                (("2"
                                  (replace -1 -2)
                                  (("2"
                                    (assert -2)
                                    (("2"
                                      (lemma card_remove)
                                      (("2"
                                        (inst -1 "fullset" _)
                                        (("1"
                                          (inst -1 "proc(alpha)")
                                          (("1"
                                            (expand "fullset" -1 3)
                                            (("1"
                                              (lemma lemma_6)
                                              (("1"
                                                (replace -1 -2)
                                                (("1"
                                                  (grind 1)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (inst 1 THREADS id)
                                          (("2" (grind 1) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("3" (inv-apply inv_19 s0)
                  (("3" (expand "QQnotIn8")
                    (("3" (inst inv_19 p)
                      (("3" (notice inv_19)
                        (("3" (move-to-front 2)
                          (("3" (induct n)
                            (("1" (flatten 1)
                              (("1"
                                (lemma card_emptyset)
                                (("1"
                                  (lemma card_add)
                                  (("1"
                                    (inst
                                     -1
                                     "s0`S(proc(alpha))"
                                     "s0`qq(proc(alpha))")
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert 1)
                              (("2"
                                (flatten 1)
                                (("2"
                                  (comment
                                   "|C|≠THREADS in s1, because we removed an element.")
                                  (("2"
                                    (replace -3)
                                    (("2"
                                      (reset-facts)
                                      (("2"
                                        (inv-apply inv_20 s0)
                                        (("2"
                                          (expand "CAndS")
                                          (("2"
                                            (inst inv_20 p "s0`qq(p)")
                                            (("2"
                                              (replace inv_19 inv_20)
                                              (("2"
                                                (delete inv_19)
                                                (("2"
                                                  (flatten inv_20)
                                                  (("2"
                                                    (with-labels
                                                     (lemma
                                                      card_remove)
                                                     (("card_rem")))
                                                    (("2"
                                                      (inst
                                                       card_rem
                                                       "s0`C(p)"
                                                       "s0`qq(p)")
                                                      (("2"
                                                        (assert inv_20)
                                                        (("2"
                                                          (replace
                                                           inv_20
                                                           card_rem)
                                                          (("2"
                                                            (delete
                                                             inv_20)
                                                            (("2"
                                                              (in-fact
                                                               "card(s0`C(p))=card(s1`C(p))+1")
                                                              (("2"
                                                                (in-fact
                                                                 "card(s0`C(p))=THREADS+1")
                                                                (("2"
                                                                  (inv-apply
                                                                   inv_22
                                                                   s0)
                                                                  (("2"
                                                                    (expand
                                                                     "BoundedCCardinality")
                                                                    (("2"
                                                                      (inst?
                                                                       inv_22)
                                                                      (("2"
                                                                        (hide-all-but
                                                                         (-1
                                                                          -2))
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    ";;; |C|≠THREADS in s1, because we removed an element."))
                                  nil))
                                nil))
                              nil)
                             ("3" (skos 1 j)
                              (("3"
                                (flatten-disjunct 1 :depth 1)
                                (("3"
                                  (lemma card_add)
                                  (("3"
                                    (lemma card_remove)
                                    (("3"
                                      (inst
                                       -1
                                       "s0`C(proc(alpha))"
                                       "s0`qq(proc(alpha))")
                                      (("3"
                                        (inst
                                         -2
                                         "s0`S(proc(alpha))"
                                         "s0`qq(proc(alpha))")
                                        (("3"
                                          (inv-apply inv_20 s0)
                                          (("3"
                                            (expand "CAndS")
                                            (("3"
                                              (inst -1 p "s0`qq(p)")
                                              (("3"
                                                (replace -6)
                                                (("3"
                                                  (expand "member" -1)
                                                  (("3"
                                                    (flatten -1)
                                                    (("3"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("4" (lemma card_emptyset)
                  (("4" (lemma lemma_6) (("4" (grind 1) nil nil)) nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("5" (lemma card_emptyset)
                  (("5" (lemma lemma_6) (("5" (grind 1) nil nil)) nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("6" (skos concl n)
                  (("6" (inst ind-hyp n)
                    (("6" (lemma card_add)
                      (("6" (inst -1 "emptyset" "proc(alpha)")
                        (("6" (expand "emptyset" -1 3)
                          (("6" (lemma card_emptyset)
                            (("6" (replace -1 -2)
                              (("6"
                                (assert -2)
                                (("6"
                                  (lemma card_remove)
                                  (("6"
                                    (inst -1 "fullset" _)
                                    (("1"
                                      (inst -1 "proc(alpha)")
                                      (("1"
                                        (expand "fullset" -1 3)
                                        (("1"
                                          (lemma lemma_6)
                                          (("1"
                                            (replace -1 -2)
                                            (("1" (grind 1) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (inst 1 THREADS id)
                                      (("2" (grind 1) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                nil))
              nil))
            nil)
           ("2" (inst ind-hyp p _) (("2" (for-alpha :lazy? nil) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (inv_19 formula-decl nil Lemmata nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (TRUE const-decl "bool" booleans nil)
    (CAndS const-decl "bool" Lemmata nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (inv_22 formula-decl nil Lemmata nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (BoundedCCardinality const-decl "bool" Lemmata nil)
    (inv_20 formula-decl nil Lemmata nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (QQnotIn8 const-decl "bool" Lemmata nil)
    (card_add formula-decl nil finite_sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (fullset const-decl "set" sets nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (/= const-decl "boolean" notequal nil)
    (action_lock10_eta formula-decl nil actions nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (Effect const-decl "cState" FilterLock nil)
    (transition const-decl "bool" IOA nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lemma_6 formula-decl nil Lemmata nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (card_emptyset formula-decl nil finite_sets nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (CAndSSize const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_8 0
  (inv_8-1 nil 3839499930
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "WinnerIsWinner")
          (("1" (skeep)
            (("1" (inst?)
              (("1" (flatten)
                (("1" (case "j=0")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)
                   ("2" (inst?)
                    (("2" (replace 1) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "WinnerIsWinner")
      (("2" (skos concl p j)
        (("2" (inst ind-hyp p j)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil)
              (("1" (inv-apply inv_16 s0)
                (("1" (expand "IIsOne" inv_16)
                  (("1" (inst inv_16 p)
                    (("1" (notice inv_16)
                      (("1" (fact j=0) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (remove const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (IIsOne const-decl "bool" Lemmata nil)
    (inv_16 formula-decl nil Lemmata nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil)
    (Winner const-decl "bool" Lemmata nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (WinnerIsWinner const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_9 0
  (inv_9-1 nil 3839519150
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "WinnerIsWinnerInv")
          (("1" (skeep)
            (("1" (inst?)
              (("1" (flatten)
                (("1" (expand "Winner")
                  (("1" (split)
                    (("1" (fact j=0) (("1" (grind) nil nil)) nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "WinnerIsWinnerInv")
      (("2" (skos concl p j)
        (("2" (inst ind-hyp p j)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil)
              (("1" (inv-apply inv_16 s0)
                (("1" (expand "IIsOne" inv_16)
                  (("1" (inst inv_16 p)
                    (("1" (notice inv_16) (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
               ("2" (flatten concl)
                (("2" (expand Winner concl)
                  (("2" (split concl)
                    (("1" (fact j=0)
                      (("1" (expand "Winner" ind-hyp)
                        (("1" (inv-apply inv_15 s0)
                          (("1" (expand "CSI" inv_15)
                            (("1" (inst inv_15 p)
                              (("1"
                                (notice inv_15)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((remove const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_lock10_eta formula-decl nil actions nil)
    (add const-decl "(nonempty?)" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (IIsOne const-decl "bool" Lemmata nil)
    (inv_16 formula-decl nil Lemmata nil)
    (inv_15 formula-decl nil Lemmata nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (CSI const-decl "bool" Lemmata nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (Winner const-decl "bool" Lemmata nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (WinnerIsWinnerInv const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_10 0
  (inv_10-1 nil 3839519350
   ("" (inv-apply inv_8 s0)
    (("" (inv-apply inv_9 s0) (("" (grind) nil nil)) nil)) nil)
   ((inv_9 formula-decl nil Lemmata nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (Winner const-decl "bool" Lemmata nil)
    (member const-decl "bool" sets nil)
    (WinnerCharacterization const-decl "bool" Lemmata nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (external adt-def-decl "boolean" actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (action type-decl nil actions nil)
    (cState type-eq-decl nil FilterLock nil)
    (PCs type-decl nil FilterLock nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (THREADS const-decl "above(1)" PROC nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (WinnerIsWinnerInv const-decl "bool" Lemmata nil)
    (WinnerIsWinner const-decl "bool" Lemmata nil)
    (invariant const-decl "bool" invariant nil)
    (inv_8 formula-decl nil Lemmata nil))
   shostak))
 (inv_11 0
  (inv_11-1 nil 3839519460
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "HierarchicalWinners")
          (("1" (skeep)
            (("1" (inst?) (("1" (flatten) (("1" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "HierarchicalWinners")
      (("2" (skos concl p j)
        (("2" (inst ind-hyp p j)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil) nil nil) ("2" (for-alpha :lazy? nil) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Winner const-decl "bool" Lemmata nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (HierarchicalWinners const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_12 0
  (inv_12-1 nil 3839558366
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "HierarchicalWinnerAndComp")
          (("1" (skeep)
            (("1" (inst?) (("1" (flatten) (("1" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "HierarchicalWinnerAndComp")
      (("2" (skos concl p j)
        (("2" (inst ind-hyp p j)
          (("2" (case "proc(alpha)=p")
            (("1" (flatten concl)
              (("1" (expand "Competitor" concl)
                (("1" (split concl)
                  (("1" (post-it inv_11)
                    (("1" (expand "HierarchicalWinners")
                      (("1" (inst conseq p j)
                        (("1" (notice conseq) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (for-alpha :lazy? nil) nil nil))
                  nil))
                nil))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((HierarchicalWinners const-decl "bool" Lemmata nil)
    (inv_11 formula-decl nil Lemmata nil)
    (reachable? inductive-decl "bool" IOA nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (/= const-decl "boolean" notequal nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (empty? const-decl "bool" sets nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (member const-decl "bool" sets nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (action_lock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (Effect const-decl "cState" FilterLock nil)
    (transition const-decl "bool" IOA nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Competitor const-decl "bool" Lemmata nil)
    (CheckVictim const-decl "bool" Lemmata nil)
    (CheckFlag const-decl "bool" Lemmata nil)
    (Winner const-decl "bool" Lemmata nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (HierarchicalWinnerAndComp const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_13 0
  (inv_13-1 nil 3839519533
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "SubsetWs")
          (("1" (skos 1 j)
            (("1" (expand "subset?")
              (("1" (skos 1 x)
                (("1" (flatten)
                  (("1" (inst -1 proc_inst)
                    (("1" (flatten)
                      (("1" (inst -6 1+j) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "SubsetWs")
      (("2" (skos concl j)
        (("2" (inst ind-hyp j)
          (("2" (expand "subset?")
            (("2" (skos concl x)
              (("2" (inst ind-hyp x)
                (("2" (flatten concl)
                  (("2" (for-alpha :lazy? nil)
                    (("1"
                      (with-labels (post-it inv_11) (("inv_h_winn")))
                      (("1" (expand "HierarchicalWinners" inv_h_winn)
                        (("1" (inst inv_h_winn "x" j)
                          (("1"
                            (with-labels (post-it inv_10)
                             (("inv_winn_c")))
                            (("1"
                              (expand "WinnerCharacterization"
                                      inv_winn_c)
                              (("1"
                                (inst inv_winn_c "x" 1+j)
                                (("1"
                                  (replace concl inv_winn_c)
                                  (("1"
                                    (flatten inv_winn_c)
                                    (("1"
                                      (notice inv_h_winn)
                                      (("1"
                                        (with-labels
                                         (post-it inv_10)
                                         (("inv_winn_c_2")))
                                        (("1"
                                          (expand
                                           "WinnerCharacterization"
                                           inv_winn_c_2)
                                          (("1"
                                            (inst inv_winn_c_2 x j)
                                            (("1"
                                              (replace
                                               inv_h_winn
                                               inv_winn_c_2)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                     ("2"
                      (with-labels (post-it inv_11) (("inv_h_winn")))
                      (("2" (expand "HierarchicalWinners" inv_h_winn)
                        (("2" (inst inv_h_winn "x" j)
                          (("2"
                            (with-labels (post-it inv_10)
                             (("inv_winn_c")))
                            (("2"
                              (expand "WinnerCharacterization"
                                      inv_winn_c)
                              (("2"
                                (inst inv_winn_c "x" 1+j)
                                (("2"
                                  (replace concl inv_winn_c)
                                  (("2"
                                    (flatten inv_winn_c)
                                    (("2"
                                      (notice inv_h_winn)
                                      (("2"
                                        (with-labels
                                         (post-it inv_10)
                                         (("inv_winn_c_2")))
                                        (("2"
                                          (expand
                                           "WinnerCharacterization"
                                           inv_winn_c_2)
                                          (("2"
                                            (inst inv_winn_c_2 x j)
                                            (("2"
                                              (replace
                                               inv_h_winn
                                               inv_winn_c_2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                     ("3"
                      (with-labels (post-it inv_11) (("inv_h_winn")))
                      (("3" (expand "HierarchicalWinners" inv_h_winn)
                        (("3" (inst inv_h_winn "x" j)
                          (("3"
                            (with-labels (post-it inv_10)
                             (("inv_winn_c")))
                            (("3"
                              (expand "WinnerCharacterization"
                                      inv_winn_c)
                              (("3"
                                (inst inv_winn_c "x" 1+j)
                                (("3"
                                  (replace concl inv_winn_c)
                                  (("3"
                                    (flatten inv_winn_c)
                                    (("3"
                                      (notice inv_h_winn)
                                      (("3"
                                        (with-labels
                                         (post-it inv_10)
                                         (("inv_winn_c_2")))
                                        (("3"
                                          (expand
                                           "WinnerCharacterization"
                                           inv_winn_c_2)
                                          (("3"
                                            (inst inv_winn_c_2 x j)
                                            (("3"
                                              (replace
                                               inv_h_winn
                                               inv_winn_c_2)
                                              (("3" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                     ("4"
                      (with-labels (post-it inv_11) (("inv_h_winn")))
                      (("4" (expand "HierarchicalWinners" inv_h_winn)
                        (("4" (inst inv_h_winn "x" j)
                          (("4"
                            (with-labels (post-it inv_10)
                             (("inv_winn_c")))
                            (("4"
                              (expand "WinnerCharacterization"
                                      inv_winn_c)
                              (("4"
                                (inst inv_winn_c "x" 1+j)
                                (("4"
                                  (replace concl inv_winn_c)
                                  (("4"
                                    (flatten inv_winn_c)
                                    (("4"
                                      (notice inv_h_winn)
                                      (("4"
                                        (with-labels
                                         (post-it inv_10)
                                         (("inv_winn_c_2")))
                                        (("4"
                                          (expand
                                           "WinnerCharacterization"
                                           inv_winn_c_2)
                                          (("4"
                                            (inst inv_winn_c_2 x j)
                                            (("4"
                                              (replace
                                               inv_h_winn
                                               inv_winn_c_2)
                                              (("4" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reachable? inductive-decl "bool" IOA nil)
    (inv_11 formula-decl nil Lemmata nil)
    (WinnerCharacterization const-decl "bool" Lemmata nil)
    (inv_10 formula-decl nil Lemmata nil)
    (HierarchicalWinners const-decl "bool" Lemmata nil)
    (empty? const-decl "bool" sets nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (/= const-decl "boolean" notequal nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (action_lock10_eta formula-decl nil actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (Effect const-decl "cState" FilterLock nil)
    (transition const-decl "bool" IOA nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (proc_inst const-decl "PROC" PROC nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (SubsetWs const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_1 0
  (inv_1-1 nil 3839521454
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand Lemma21)
          (("1" (split 1)
            (("1" (skeep) (("1" (grind) nil nil)) nil)
             ("2" (skeep) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "Lemma21")
      (("2" (with-labels (flatten ind-hyp) (("ind-hyp-1" "ind-hyp-2")))
        (("2" (split concl)
          (("1" (hide ind-hyp-2)
            (("1" (skos concl p q j)
              (("1"
                (with-labels (case "proc(alpha)=p OR proc(alpha)=q")
                 (("exec")))
                (("1" (split exec)
                  (("1" (reset-facts)
                    (("1"
                      (with-labels (flatten)
                       (("js" "comp-p" "cf" "comp-q" "mem-q" "concl")))
                      (("1"
                        (with-labels (inv-apply lemma_2 s0) ((comp-q)))
                        (("1" (inst comp-q s0 s1 q alpha j)
                          (("1" (replace tran)
                            (("1" (fact "proc(alpha)/=q")
                              (("1"
                                (replace fact-1)
                                (("1"
                                  (delete fact-1)
                                  (("1"
                                    (notice comp-q)
                                    (("1"
                                      (with-labels
                                       (move-to-front comp-q)
                                       (("comp-q")))
                                      (("1"
                                        (inst ind-hyp-1 p q j)
                                        (("1"
                                          (for-alpha :lazy? nil-lazy)
                                          (("1"
                                            (replace eff cf)
                                            (("1"
                                              (replace exec cf)
                                              (("1"
                                                (expand "CheckFlag" cf)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("2"
                                            (replace eff cf)
                                            (("2"
                                              (replace exec cf)
                                              (("2"
                                                (expand "CheckFlag" cf)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("3"
                                            (replace eff cf)
                                            (("3"
                                              (replace exec cf)
                                              (("3"
                                                (expand "CheckFlag" cf)
                                                (("3"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("4"
                                            (replace -13 cf)
                                            (("4"
                                              (replace exec cf)
                                              (("4"
                                                (expand "CheckFlag")
                                                (("4"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("5"
                                            (replace -13 cf)
                                            (("5"
                                              (replace exec cf)
                                              (("5"
                                                (expand "CheckFlag")
                                                (("5"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("6"
                                            (replace eff cf)
                                            (("6"
                                              (replace exec cf)
                                              (("6"
                                                (expand "CheckFlag")
                                                (("6"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("7"
                                            (replace eff mem-q)
                                            (("7"
                                              (beta mem-q)
                                              (("7"
                                                (expand member mem-q)
                                                (("7"
                                                  (expand add mem-q)
                                                  (("7"
                                                    (expand
                                                     emptyset
                                                     mem-q)
                                                    (("7"
                                                      (grind mem-q)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("8"
                                            (replace eff mem-q)
                                            (("8"
                                              (replace exec mem-q)
                                              (("8"
                                                (beta mem-q)
                                                (("8"
                                                  (grind mem-q)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("9"
                                            (reset-facts)
                                            (("9"
                                              (in-fact
                                               "Competitor(s0, p, j)")
                                              (("9"
                                                (notice ind-hyp-1)
                                                (("9" (grind) nil nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("10"
                                            (replace -13 cf)
                                            (("10"
                                              (replace exec cf)
                                              (("10"
                                                (expand "CheckFlag")
                                                (("10"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("11"
                                            (case
                                             "q=s0`qq(proc(alpha))")
                                            (("1"
                                              (expand
                                               "Competitor"
                                               comp-p)
                                              (("1"
                                                (expand
                                                 "Winner"
                                                 comp-p)
                                                (("1"
                                                  (split comp-p)
                                                  (("1"
                                                    (show ind-hyp-2)
                                                    (("1"
                                                      (inst
                                                       ind-hyp-2
                                                       p
                                                       q
                                                       j)
                                                      (("1"
                                                        (replace
                                                         comp-q)
                                                        (("1"
                                                          (reset-facts)
                                                          (("1"
                                                            (fact p/=q)
                                                            (("1"
                                                              (replace
                                                               fact-1)
                                                              (("1"
                                                                (delete
                                                                 fact-1)
                                                                (("1"
                                                                  (in-fact
                                                                   "s0`i(p)>j")
                                                                  (("1"
                                                                    (expand
                                                                     "Winner")
                                                                    (("1"
                                                                      (notice
                                                                       ind-hyp-2)
                                                                      (("1"
                                                                        (hide-all-but
                                                                         (ind-hyp-2
                                                                          concl
                                                                          eff))
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("3"
                                                    (flatten comp-p)
                                                    (("3"
                                                      (in-fact
                                                       "s0`i(p) = j")
                                                      (("3"
                                                        (expand
                                                         "Competitor"
                                                         -5)
                                                        (("3"
                                                          (expand
                                                           "Winner"
                                                           -5)
                                                          (("3"
                                                            (split -5)
                                                            (("1"
                                                              (inv-apply
                                                               inv_18
                                                               s0)
                                                              (("1"
                                                                (expand
                                                                 "LevelRange")
                                                                (("1"
                                                                  (inst
                                                                   inv_18
                                                                   q)
                                                                  (("1"
                                                                    (in-fact
                                                                     "j < s0`level(q)")
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (inv-apply
                                                               inv_17
                                                               s0)
                                                              (("2"
                                                                (expand
                                                                 "LevelValue")
                                                                (("2"
                                                                  (inst
                                                                   inv_17
                                                                   q)
                                                                  (("2"
                                                                    (notice
                                                                     inv_17)
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("3"
                                                              (flatten
                                                               comp-q)
                                                              (("3"
                                                                (inv-apply
                                                                 inv_17
                                                                 s0)
                                                                (("3"
                                                                  (expand
                                                                   "LevelValue")
                                                                  (("3"
                                                                    (inst
                                                                     inv_17
                                                                     q)
                                                                    (("3"
                                                                      (notice
                                                                       inv_17)
                                                                      (("3"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (in-fact
                                               "member(q, s0`S(p))")
                                              (("2"
                                                (in-fact
                                                 "Competitor(s0, p, j)")
                                                (("2"
                                                  (notice ind-hyp-1)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("12"
                                            (replace -13 cf)
                                            (("12"
                                              (replace exec cf)
                                              (("12"
                                                (expand "CheckFlag")
                                                (("12"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("13"
                                            (reset-facts)
                                            (("13"
                                              (in-fact
                                               "Competitor(s0, p, j)")
                                              (("13"
                                                (in-fact
                                                 "member(q, s0`S(p))")
                                                (("13"
                                                  (notice ind-hyp-1)
                                                  (("13"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("14"
                                            (replace -13 cf)
                                            (("14"
                                              (replace exec cf)
                                              (("14"
                                                (expand "CheckFlag")
                                                (("14"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("15"
                                            (replace -13 mem-q)
                                            (("15"
                                              (beta mem-q)
                                              (("15"
                                                (expand
                                                 "emptyset"
                                                 mem-q)
                                                (("15"
                                                  (expand "add" mem-q)
                                                  (("15"
                                                    (expand
                                                     "member"
                                                     mem-q)
                                                    (("15"
                                                      (grind mem-q)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("16"
                                            (replace -12 cf)
                                            (("16"
                                              (replace exec cf)
                                              (("16"
                                                (expand "CheckFlag")
                                                (("16"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("17"
                                            (replace eff cf)
                                            (("17"
                                              (replace exec cf)
                                              (("17"
                                                (expand "CheckFlag")
                                                (("17"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                           ("18"
                                            (replace eff cf)
                                            (("18"
                                              (replace exec cf)
                                              (("18"
                                                (expand "CheckFlag")
                                                (("18"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inv-apply lemma_2 s0)
                    (("2" (inst lemma_2 s0 s1 p alpha j)
                      (("2" (replace tran)
                        (("2" (reset-facts)
                          (("2" (fact "proc(alpha)/=p")
                            (("2" (replace fact-1)
                              (("2"
                                (delete fact-1)
                                (("2"
                                  (with-labels
                                   (flatten concl)
                                   (("js"
                                     "comp-p"
                                     "cf"
                                     "comp-q"
                                     "q-in-S"
                                     "concl")))
                                  (("2"
                                    (replace comp-p)
                                    (("2"
                                      (label "comp-p" -1)
                                      (("2"
                                        (with-labels
                                         (move-to-front (comp-p))
                                         ((comp-p)))
                                        (("2"
                                          (inst ind-hyp-1 p q j)
                                          (("2"
                                            (replace comp-p)
                                            (("2"
                                              (fact p/=q)
                                              (("2"
                                                (replace fact-2)
                                                (("2"
                                                  (delete fact-2)
                                                  (("2"
                                                    (replace js)
                                                    (("2"
                                                      (inv-apply
                                                       lemma_3
                                                       s0)
                                                      (("2"
                                                        (inst
                                                         lemma_3
                                                         s0
                                                         s1
                                                         alpha
                                                         p)
                                                        (("2"
                                                          (replace
                                                           reach)
                                                          (("2"
                                                            (replace
                                                             tran)
                                                            (("2"
                                                              (fact
                                                               "proc(alpha)/=p")
                                                              (("2"
                                                                (replace
                                                                 fact-3)
                                                                (("2"
                                                                  (delete
                                                                   fact-3)
                                                                  (("2"
                                                                    (in-fact
                                                                     "CheckFlag(s0, p)")
                                                                    (("2"
                                                                      (label
                                                                       cf
                                                                       fact-4)
                                                                      (("2"
                                                                        (replace
                                                                         cf)
                                                                        (("2"
                                                                          (expand
                                                                           "Competitor"
                                                                           comp-q)
                                                                          (("2"
                                                                            (expand
                                                                             "Winner"
                                                                             comp-q)
                                                                            (("2"
                                                                              (delete
                                                                               cf)
                                                                              (("2"
                                                                                (delete
                                                                                 comp-p)
                                                                                (("2"
                                                                                  (delete
                                                                                   lemma_3)
                                                                                  (("2"
                                                                                    (hide
                                                                                     reach)
                                                                                    (("2"
                                                                                      (split
                                                                                       comp-q)
                                                                                      (("1"
                                                                                        (fact
                                                                                         "s1`i(q)>=2")
                                                                                        (("1"
                                                                                          (for-alpha :lazy? nil-lazy)
                                                                                          (("1"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("3"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("4"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("5"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("6"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("7"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("8"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("9"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("10"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("11"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("12"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("13"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("14"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("15"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("16"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("17"
                                                                                            (fact
                                                                                             "s0`i(q)>=j")
                                                                                            (("17"
                                                                                              (case
                                                                                               "s0`i(q)>j")
                                                                                              (("1"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil)
                                                                                               ("2"
                                                                                                (expand
                                                                                                 "Competitor")
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   "Winner")
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                                                           ("18"
                                                                                            (assert)
                                                                                            nil
                                                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (for-alpha :lazy? nil)
                                                                                        nil
                                                                                        nil)
                                                                                       ("3"
                                                                                        (for-alpha :lazy? nil)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (reset-facts)
                  (("2" (inv-apply lemma_2 s0)
                    (("2" (inv-apply lemma_2 s0)
                      (("2" (inst lemma_2 s0 s1 p alpha j)
                        (("2" (inst lemma_2 s0 s1 q alpha j)
                          (("2" (replace tran)
                            (("2" (in-fact "proc(alpha)/=p")
                              (("2"
                                (in-fact "proc(alpha)/=q")
                                (("2"
                                  (replace fact-1)
                                  (("2"
                                    (replace fact-2)
                                    (("2"
                                      (delete (fact-2 fact-1))
                                      (("2"
                                        (flatten concl)
                                        (("2"
                                          (notice lemma_2)
                                          (("2"
                                            (notice lemma_2)
                                            (("2"
                                              (inst ind-hyp-1 p q j)
                                              (("2"
                                                (replace lemma_2)
                                                (("2"
                                                  (fact p/=q)
                                                  (("2"
                                                    (replace fact-3)
                                                    (("2"
                                                      (replace
                                                       -3
                                                       ind-hyp-1)
                                                      (("2"
                                                        (hide lemma_2)
                                                        (("2"
                                                          (replace -2)
                                                          (("2"
                                                            (hide
                                                             -3
                                                             -5)
                                                            (("2"
                                                              (hide
                                                               reach)
                                                              (("2"
                                                                (for-alpha :lazy? nil)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide ind-hyp-1)
            (("2" (skos concl p q j)
              (("2" (inst ind-hyp-2 p q j)
                (("2"
                  (with-labels (case "proc(alpha)=p OR proc(alpha)=q")
                   (("exec")))
                  (("1" (split exec)
                    (("1" (inv-apply lemma_2 s0)
                      (("1" (inst lemma_2 s0 s1 q alpha j)
                        (("1" (reset-facts)
                          (("1" (replace tran)
                            (("1" (fact "proc(alpha)/=q")
                              (("1"
                                (replace fact-1)
                                (("1"
                                  (delete fact-1)
                                  (("1"
                                    (with-labels
                                     (flatten concl)
                                     (("js"
                                       "winn-p"
                                       "comp-q"
                                       "p-is-not-q"
                                       "concl")))
                                    (("1"
                                      (replace comp-q)
                                      (("1"
                                        (label comp-q -1)
                                        (("1"
                                          (with-labels
                                           (move-to-front (comp-q))
                                           ((comp-q)))
                                          (("1"
                                            (fact p/=q)
                                            (("1"
                                              (replace fact-2)
                                              (("1"
                                                (replace comp-q)
                                                (("1"
                                                  (delete fact-2)
                                                  (("1"
                                                    (replace js)
                                                    (("1"
                                                      (expand
                                                       "Winner"
                                                       winn-p)
                                                      (("1"
                                                        (split winn-p)
                                                        (("1"
                                                          (for-alpha :lazy? nil)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (for-alpha :lazy? nil)
                                                          (("1"
                                                            (reset-facts)
                                                            (("1"
                                                              (fact
                                                               "s0`i(p)=j")
                                                              (("1"
                                                                (show
                                                                 ind-hyp-1)
                                                                (("1"
                                                                  (inst
                                                                   ind-hyp-1
                                                                   p
                                                                   q
                                                                   j)
                                                                  (("1"
                                                                    (replace
                                                                     comp-q)
                                                                    (("1"
                                                                      (replace
                                                                       js)
                                                                      (("1"
                                                                        (fact
                                                                         p/=q)
                                                                        (("1"
                                                                          (replace
                                                                           fact-2)
                                                                          (("1"
                                                                            (delete
                                                                             fact-2)
                                                                            (("1"
                                                                              (expand
                                                                               "Competitor"
                                                                               ind-hyp-1)
                                                                              (("1"
                                                                                (expand
                                                                                 "Winner"
                                                                                 ind-hyp-1)
                                                                                (("1"
                                                                                  (expand
                                                                                   "CheckFlag"
                                                                                   ind-hyp-1)
                                                                                  (("1"
                                                                                    (replace
                                                                                     exec)
                                                                                    (("1"
                                                                                      (replace
                                                                                       eff
                                                                                       ind-hyp-1)
                                                                                      (("1"
                                                                                        (replace
                                                                                         fact-1
                                                                                         ind-hyp-1)
                                                                                        (("1"
                                                                                          (comment
                                                                                           "C is empty, hence q can be in the set or not.")
                                                                                          (("1"
                                                                                            (case
                                                                                             "member(q, s0`S(p))")
                                                                                            (("1"
                                                                                              (notice
                                                                                               ind-hyp-1)
                                                                                              (("1"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil))
                                                                                              nil)
                                                                                             ("2"
                                                                                              (in-fact
                                                                                               "empty?(s0`C(p))")
                                                                                              (("2"
                                                                                                (rewrite
                                                                                                 "emptyset_is_empty?"
                                                                                                 -1)
                                                                                                (("2"
                                                                                                  (inv-apply
                                                                                                   inv_21
                                                                                                   s0)
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     "SComplementOfC")
                                                                                                    (("2"
                                                                                                      (inst?)
                                                                                                      (("2"
                                                                                                        (replace
                                                                                                         -2
                                                                                                         inv_21)
                                                                                                        (("2"
                                                                                                          (rewrite
                                                                                                           "complement_emptyset"
                                                                                                           inv_21)
                                                                                                          (("2"
                                                                                                            (grind)
                                                                                                            nil
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            ";;; C is empty, hence q can be in the set or not."))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                                           ("2"
                                                            (show
                                                             ind-hyp-1)
                                                            (("2"
                                                              (inst
                                                               ind-hyp-1
                                                               p
                                                               q
                                                               j)
                                                              (("2"
                                                                (replace
                                                                 comp-q)
                                                                (("2"
                                                                  (reset-facts)
                                                                  (("2"
                                                                    (replace
                                                                     js)
                                                                    (("2"
                                                                      (fact
                                                                       p/=q)
                                                                      (("2"
                                                                        (replace
                                                                         fact-1)
                                                                        (("2"
                                                                          (delete
                                                                           fact-1)
                                                                          (("2"
                                                                            (expand
                                                                             "Competitor"
                                                                             ind-hyp-1)
                                                                            (("2"
                                                                              (expand
                                                                               "CheckFlag"
                                                                               ind-hyp-1)
                                                                              (("2"
                                                                                (fact
                                                                                 "s0`i(p)=j")
                                                                                (("2"
                                                                                  (replace
                                                                                   fact-2
                                                                                   ind-hyp-1)
                                                                                  (("2"
                                                                                    (replace
                                                                                     exec)
                                                                                    (("2"
                                                                                      (replace
                                                                                       -12
                                                                                       ind-hyp-1)
                                                                                      (("2"
                                                                                        (delete
                                                                                         fact-2)
                                                                                        (("2"
                                                                                          (case
                                                                                           "member(q, s0`S(p))")
                                                                                          (("1"
                                                                                            (notice
                                                                                             ind-hyp-1)
                                                                                            (("1"
                                                                                              (grind)
                                                                                              nil
                                                                                              nil))
                                                                                            nil)
                                                                                           ("2"
                                                                                            (inv-apply
                                                                                             inv_23
                                                                                             s0)
                                                                                            (("2"
                                                                                              (expand
                                                                                               "CAndSSize")
                                                                                              (("2"
                                                                                                (inst
                                                                                                 -1
                                                                                                 p
                                                                                                 THREADS)
                                                                                                (("2"
                                                                                                  (replace
                                                                                                   -11
                                                                                                   -1)
                                                                                                  (("2"
                                                                                                    (flatten
                                                                                                     -1)
                                                                                                    (("2"
                                                                                                      (assert
                                                                                                       -1)
                                                                                                      (("2"
                                                                                                        (lemma
                                                                                                         card_empty?)
                                                                                                        (("2"
                                                                                                          (inst
                                                                                                           -1
                                                                                                           "s0`C(p)")
                                                                                                          (("2"
                                                                                                            (replace
                                                                                                             -2
                                                                                                             -1)
                                                                                                            (("2"
                                                                                                              (rewrite
                                                                                                               "emptyset_is_empty?"
                                                                                                               -1)
                                                                                                              (("2"
                                                                                                                (inv-apply
                                                                                                                 inv_21
                                                                                                                 s0)
                                                                                                                (("2"
                                                                                                                  (expand
                                                                                                                   "SComplementOfC")
                                                                                                                  (("2"
                                                                                                                    (inst?)
                                                                                                                    (("2"
                                                                                                                      (replace
                                                                                                                       -2
                                                                                                                       inv_21)
                                                                                                                      (("2"
                                                                                                                        (rewrite
                                                                                                                         "complement_emptyset"
                                                                                                                         inv_21)
                                                                                                                        (("2"
                                                                                                                          (grind)
                                                                                                                          nil
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2"
                      (with-labels (flatten concl)
                       (("js" "winn-p" "comp-q" "q-in-S" "concl")))
                      (("2" (inv-apply lemma_1 s0)
                        (("2" (inst lemma_1 s0 s1 p alpha j)
                          (("2" (replace tran)
                            (("2" (replace winn-p)
                              (("2"
                                (reset-facts)
                                (("2"
                                  (fact "proc(alpha)/=p")
                                  (("2"
                                    (replace fact-1)
                                    (("2"
                                      (delete fact-1)
                                      (("2"
                                        (label winn-p lemma_1)
                                        (("2"
                                          (with-labels
                                           (move-to-front (winn-p))
                                           ((winn-p)))
                                          (("2"
                                            (replace winn-p)
                                            (("2"
                                              (replace js)
                                              (("2"
                                                (fact p/=q)
                                                (("2"
                                                  (replace fact-2)
                                                  (("2"
                                                    (delete fact-2)
                                                    (("2"
                                                      (for-alpha :lazy? nil)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inv-apply lemma_2 s0)
                    (("2" (inv-apply lemma_1 s0)
                      (("2" (inst lemma_1 s0 s1 p alpha j)
                        (("2" (inst lemma_2 s0 s1 q alpha j)
                          (("2" (replace tran)
                            (("2" (reset-facts)
                              (("2"
                                (fact "proc(alpha)/=q")
                                (("2"
                                  (fact "proc(alpha)/=p")
                                  (("2"
                                    (replace fact-1)
                                    (("2"
                                      (replace fact-2)
                                      (("2"
                                        (delete (fact-2 fact-1))
                                        (("2"
                                          (with-labels
                                           (flatten concl)
                                           (("js"
                                             "winn-p"
                                             "comp-q"
                                             "p-is-not-q"
                                             "concl")))
                                          (("2"
                                            (replace winn-p)
                                            (("2"
                                              (replace comp-q)
                                              (("2"
                                                (notice ind-hyp-2)
                                                (("2"
                                                  (delete lemma_1)
                                                  (("2"
                                                    (delete lemma_2)
                                                    (("2"
                                                      (delete winn-p)
                                                      (("2"
                                                        (delete comp-q)
                                                        (("2"
                                                          (delete js)
                                                          (("2"
                                                            (for-alpha :lazy? nil)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (add const-decl "(nonempty?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (inv_17 formula-decl nil Lemmata nil)
    (LevelValue const-decl "bool" Lemmata nil)
    (inv_18 formula-decl nil Lemmata nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (LevelRange const-decl "bool" Lemmata nil)
    (lemma_2 formula-decl nil Lemmata nil)
    (TRUE const-decl "bool" booleans nil)
    (lemma_3 formula-decl nil Lemmata nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (lemma_1 formula-decl nil Lemmata nil)
    (inv_21 formula-decl nil Lemmata nil)
    (complement_emptyset formula-decl nil sets_lemmas nil)
    (fullset const-decl "set" sets nil)
    (SComplementOfC const-decl "bool" Lemmata nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (CAndSSize const-decl "bool" Lemmata nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_empty? formula-decl nil finite_sets nil)
    (inv_23 formula-decl nil Lemmata nil)
    (member const-decl "bool" sets nil)
    (Competitor const-decl "bool" Lemmata nil)
    (CheckVictim const-decl "bool" Lemmata nil)
    (CheckFlag const-decl "bool" Lemmata nil)
    (Winner const-decl "bool" Lemmata nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (Lemma21 const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_2 0
  (inv_2-1 nil 3833886527
   ("" (lemma inv_1)
    (("" (expand "invariant")
      (("" (skos 1 s0)
        (("" (inst -1 s0)
          (("" (flatten 1)
            (("" (notice -1)
              (("" (expand "Lemma21")
                (("" (expand "WinnerIsNotVictim")
                  (("" (skos 1 p q j)
                    (("" (flatten -1)
                      (("" (delete -1) (("" (inst -1 p q j) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((invariant const-decl "bool" invariant nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (WinnerIsNotVictim const-decl "bool" Lemmata nil)
    (Lemma21 const-decl "bool" Lemmata nil)
    (inv_1 formula-decl nil Lemmata nil))
   shostak))
 (inv_3 0
  (inv_3-1 nil 3839521119
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "Lemma3")
          (("1" (skeep)
            (("1" (with-labels (copy -1) (("secret")))
              (("1" (hide secret)
                (("1" (skeep)
                  (("1" (inst -1 p)
                    (("1" (expand "Competitor" -2)
                      (("1" (split)
                        (("1" (expand "Winner")
                          (("1" (split)
                            (("1" (fact j=0)
                              (("1"
                                (show secret)
                                (("1"
                                  (inst secret "s1`victim(j)")
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "Lemma3" +)
      (("2" (skos concl j)
        (("2" (flatten concl)
          (("2" (skolem -4 p)
            (("2" (case "proc(alpha)=p OR proc(alpha)=s0`victim(j)")
              (("1" (case "p=s0`victim(j)")
                (("1"
                  (in-fact
                   "proc(alpha)=p AND proc(alpha)=s0`victim(j)")
                  (("1" (flatten)
                    (("1" (replace -3 concl)
                      (("1" (case "s0`victim(j)=s1`victim(j)")
                        (("1" (for-alpha :lazy? nil) nil nil)
                         ("2" (for-alpha :lazy? nil) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split -1)
                  (("1" (expand "Lemma3")
                    (("1" (inst ind-hyp j)
                      (("1" (split ind-hyp)
                        (("1" (for-alpha :lazy? nil) nil nil)
                         ("2" (case "NOT (Competitor(s0, p, j))")
                          (("1" (for-alpha :lazy? nil)
                            (("1" (inv-apply inv_16 s0)
                              (("1"
                                (expand IIsOne inv_16)
                                (("1"
                                  (inst inv_16 "proc(alpha)")
                                  (("1"
                                    (notice inv_16)
                                    (("1"
                                      (fact j=0)
                                      (("1"
                                        (replace -3)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                             ("2" (expand "Competitor" -5)
                              (("2"
                                (expand "CheckFlag" -5)
                                (("2"
                                  (expand "CheckVictim" -5)
                                  (("2"
                                    (split -5)
                                    (("1"
                                      (expand "Winner" -1)
                                      (("1"
                                        (split -1)
                                        (("1"
                                          (expand "Competitor" 1)
                                          (("1"
                                            (expand "Winner" 1)
                                            (("1"
                                              (flatten 1)
                                              (("1"
                                                (replace eff -1)
                                                (("1"
                                                  (beta -1)
                                                  (("1"
                                                    (replace
                                                     -2
                                                     -1
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (beta -1)
                                                      (("1"
                                                        (fact j=0)
                                                        (("1"
                                                          (replace
                                                           -1
                                                           1)
                                                          (("1"
                                                            (inv-apply
                                                             inv_15
                                                             s0)
                                                            (("1"
                                                              (expand
                                                               "CSI")
                                                              (("1"
                                                                (inst
                                                                 inv_15
                                                                 p)
                                                                (("1"
                                                                  (notice
                                                                   inv_15)
                                                                  (("1"
                                                                    (replace
                                                                     inv_15)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                            nil)
                           ("2" (inst 1 p) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inv-apply lemma_2 s0)
                    (("2" (inst lemma_2 s0 s1 p alpha j)
                      (("2" (notice lemma_2)
                        (("2" (label "comp" (-1 -6))
                          (("2"
                            (with-labels (move-to-front comp)
                             (("comp")))
                            (("2" (expand "Lemma3")
                              (("2"
                                (inst ind-hyp j)
                                (("2"
                                  (split ind-hyp)
                                  (("1"
                                    (for-alpha :lazy? nil)
                                    (("1"
                                      (expand "Competitor" ind-hyp)
                                      (("1"
                                        (expand "CheckFlag")
                                        (("1"
                                          (expand "CheckVictim")
                                          (("1"
                                            (split ind-hyp)
                                            (("1"
                                              (expand "Winner")
                                              (("1"
                                                (split ind-hyp)
                                                (("1"
                                                  (inv-apply inv_16 s0)
                                                  (("1"
                                                    (expand
                                                     IIsOne
                                                     inv_16)
                                                    (("1"
                                                      (inst
                                                       inv_16
                                                       "s0`victim(j)")
                                                      (("1"
                                                        (notice inv_16)
                                                        (("1"
                                                          (fact j=0)
                                                          (("1"
                                                            (expand
                                                             "Competitor")
                                                            (("1"
                                                              (expand
                                                               "Winner")
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                                     ("2"
                                      (comment
                                       "Let's observe that the assumption of having a competitor victim only leads to contraddictions.")
                                      (("2"
                                        (expand "Competitor" ind-hyp)
                                        (("2"
                                          (split ind-hyp)
                                          (("1"
                                            (inv-apply inv_2 s0)
                                            (("1"
                                              (expand
                                               "WinnerIsNotVictim")
                                              (("1"
                                                (inst
                                                 inv_2
                                                 "s0`victim(j)"
                                                 p
                                                 j)
                                                (("1"
                                                  (replace ind-hyp)
                                                  (("1"
                                                    (replace comp)
                                                    (("1"
                                                      (reset-facts)
                                                      (("1"
                                                        (fact
                                                         "s0`victim(j)/=p")
                                                        (("1"
                                                          (replace -1)
                                                          (("1"
                                                            (delete
                                                             fact-1)
                                                            (("1"
                                                              (expand
                                                               "Competitor")
                                                              (("1"
                                                                (expand
                                                                 "Winner")
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (fact
                                                                     "s0`victim(j)=s1`victim(j)")
                                                                    (("1"
                                                                      (replace
                                                                       fact-2)
                                                                      (("1"
                                                                        (replace
                                                                         -6
                                                                         eff)
                                                                        (("1"
                                                                          (replace
                                                                           eff
                                                                           2)
                                                                          (("1"
                                                                            (beta
                                                                             concl)
                                                                            (("1"
                                                                              (replace
                                                                               fact-2
                                                                               concl)
                                                                              (("1"
                                                                                (beta
                                                                                 concl)
                                                                                (("1"
                                                                                  (fact
                                                                                   "1<=j")
                                                                                  (("1"
                                                                                    (fact
                                                                                     j>0)
                                                                                    (("1"
                                                                                      (notice
                                                                                       inv_2)
                                                                                      (("1"
                                                                                        (assert
                                                                                         inv_2)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten ind-hyp)
                                            (("2"
                                              (expand "CheckVictim")
                                              (("2"
                                                (expand "CheckFlag")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        ";;; Let's observe that the assumption of having a competitor victim only leads to contraddictions."))
                                      ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                                    nil)
                                   ("2" (inst ind-hyp p) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (inv-apply lemma_2 s0)
                (("2" (inst lemma_2 s0 s1 p alpha j)
                  (("2" (notice lemma_2)
                    (("2" (expand "Lemma3")
                      (("2" (inst ind-hyp j)
                        (("2" (split ind-hyp)
                          (("1" (for-alpha :lazy? nil) nil nil)
                           ("2" (inst ind-hyp p) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (CSI const-decl "bool" Lemmata nil)
    (inv_15 formula-decl nil Lemmata nil)
    (inv_16 formula-decl nil Lemmata nil)
    (IIsOne const-decl "bool" Lemmata nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (WinnerIsNotVictim const-decl "bool" Lemmata nil)
    (TRUE const-decl "bool" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (inv_2 formula-decl nil Lemmata nil)
    (lemma_2 formula-decl nil Lemmata nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (action_inclusive formula-decl nil actions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Competitor const-decl "bool" Lemmata nil)
    (Winner const-decl "bool" Lemmata nil)
    (CheckFlag const-decl "bool" Lemmata nil)
    (CheckVictim const-decl "bool" Lemmata nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (Lemma3 const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_4 0
  (inv_4-1 nil 3839569699
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "NotWinner2")
          (("1" (skeep)
            (("1" (inst -1 proc_inst)
              (("1" (flatten)
                (("1" (inst -6 j) (("1" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "NotWinner2")
      (("2" (skos concl j _)
        (("2" (induct n)
          (("1" (flatten)
            (("1" (lemma lemma_5)
              (("1" (inst -1 "s1`W(j)" j)
                (("1" (notice -1)
                  (("1" (flatten)
                    (("1" (skeep -1)
                      (("1" (inst?)
                        (("1" (replace -1 -3)
                          (("1" (replace -2 -3)
                            (("1" (inst -3 "s1`victim(j)")
                              (("1"
                                (replace -6 -3)
                                (("1"
                                  (post-it inv_2)
                                  (("1"
                                    (post-it inv_2)
                                    (("1"
                                      (expand "WinnerIsNotVictim")
                                      (("1"
                                        (inst -1 p q j)
                                        (("1"
                                          (inst -2 q p j)
                                          (("1"
                                            (post-it inv_10)
                                            (("1"
                                              (post-it inv_10)
                                              (("1"
                                                (expand
                                                 "WinnerCharacterization")
                                                (("1"
                                                  (inst -1 p j)
                                                  (("1"
                                                    (inst -2 q j)
                                                    (("1"
                                                      (replace -5 -1)
                                                      (("1"
                                                        (replace -6 -2)
                                                        (("1"
                                                          (flatten
                                                           (-1 -2))
                                                          (("1"
                                                            (expand
                                                             "Competitor")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               (-4 -3))
                                                              (("1"
                                                                (replace
                                                                 -2
                                                                 (-4
                                                                  -3))
                                                                (("1"
                                                                  (replace
                                                                   -8)
                                                                  (("1"
                                                                    (hide-all-but
                                                                     (-3
                                                                      -4
                                                                      -7
                                                                      1))
                                                                    (("1"
                                                                      (notice
                                                                       -1)
                                                                      (("1"
                                                                        (notice
                                                                         -2)
                                                                        (("1"
                                                                          (prop)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (label "concl" 1)
            (("2" (skos concl jj)
              (("2" (for-alpha :lazy? nil)
                (("1" (flatten concl)
                  (("1" (in-fact "card(s0`W(j)) = 2 + (jj + 1)")
                    (("1" (case "j/=s0`i(proc(alpha))")
                      (("1" (grind) nil nil)
                       ("2" (post-it inv_10)
                        (("2" (expand "WinnerCharacterization")
                          (("2" (inst -1 "proc(alpha)" j)
                            (("2" (in-fact "s1`victim(j)=proc(alpha)")
                              (("2"
                                (replace -1 -7)
                                (("2"
                                  (replace -7 -2)
                                  (("2"
                                    (flatten conseq)
                                    (("2"
                                      (expand "Winner" conseq)
                                      (("2"
                                        (split conseq)
                                        (("1"
                                          (hide-all-but (-1 1 -11))
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2"
                                          (hide-all-but (-1 -11))
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("2" (flatten concl)
                  (("2" (case "j/=s0`i(proc(alpha))")
                    (("1" (inst ind-hyp j jj+1)
                      (("1" (notice ind-hyp)
                        (("1" (hide-all-but (-1 -5 -9 1))
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (fact "j=s0`i(proc(alpha))")
                      (("2" (case "member(proc(alpha), s0`W(j))")
                        (("1" (lemma card_add)
                          (("1" (inst -1 "s0`W(j)" "proc(alpha)")
                            (("1" (assert -2)
                              (("1"
                                (replace -2 -1)
                                (("1"
                                  (in-fact
                                   "card(s0`W(j)) = 2 + (jj + 1)")
                                  (("1"
                                    (inst ind-hyp j jj+1)
                                    (("1"
                                      (notice ind-hyp)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (lemma card_add)
                          (("2" (assert 1)
                            (("2" (inst -1 "s0`W(j)" "proc(alpha)")
                              (("2"
                                (replace 1 -1)
                                (("2"
                                  (in-fact "card(s0`W(j)) = 2 + jj")
                                  (("2"
                                    (inst ind-hyp j jj)
                                    (("2"
                                      (notice ind-hyp)
                                      (("2"
                                        (case
                                         "s0`victim(j)/=proc(alpha)")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (reset-facts)
                                          (("2"
                                            (in-fact
                                             "card(s0`W(j)) >=2")
                                            (("2"
                                              (with-labels
                                               (lemma card_2_has_2)
                                               (("2_elem")))
                                              (("2"
                                                (delete fact-1)
                                                (("2"
                                                  (inst
                                                   "2_elem"
                                                   "s0`W(j)")
                                                  (("2"
                                                    (notice 2_elem)
                                                    (("2"
                                                      (skolem
                                                       2_elem
                                                       (x y))
                                                      (("2"
                                                        (in-fact
                                                         "x/=proc(alpha)")
                                                        (("2"
                                                          (in-fact
                                                           "y/=proc(alpha)")
                                                          (("2"
                                                            (in-fact
                                                             "member(proc(alpha), s1`W(j))")
                                                            (("2"
                                                              (post-it
                                                               inv_10)
                                                              (("2"
                                                                (post-it
                                                                 inv_10)
                                                                (("2"
                                                                  (post-it
                                                                   inv_10)
                                                                  (("2"
                                                                    (expand
                                                                     "WinnerCharacterization")
                                                                    (("2"
                                                                      (inst
                                                                       -1
                                                                       x
                                                                       j)
                                                                      (("2"
                                                                        (inst
                                                                         -2
                                                                         y
                                                                         j)
                                                                        (("2"
                                                                          (inst
                                                                           -3
                                                                           "proc(alpha)"
                                                                           j)
                                                                          (("2"
                                                                            (in-fact
                                                                             "Winner(s1, x, j)")
                                                                            (("2"
                                                                              (in-fact
                                                                               "Winner(s1, y, j)")
                                                                              (("2"
                                                                                (in-fact
                                                                                 "Winner(s1, proc(alpha), j)")
                                                                                (("2"
                                                                                  (delete
                                                                                   conseq)
                                                                                  (("2"
                                                                                    (delete
                                                                                     fact-4)
                                                                                    (("2"
                                                                                      (post-it
                                                                                       inv_2)
                                                                                      (("2"
                                                                                        (expand
                                                                                         "WinnerIsNotVictim")
                                                                                        (("2"
                                                                                          (inst
                                                                                           -1
                                                                                           "proc(alpha)"
                                                                                           x
                                                                                           j)
                                                                                          (("2"
                                                                                            (expand
                                                                                             "Competitor")
                                                                                            (("2"
                                                                                              (notice
                                                                                               -1)
                                                                                              (("2"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("3" (flatten concl)
                  (("3" (case "j/=s0`i(proc(alpha))")
                    (("1" (grind) nil nil)
                     ("2" (fact "j=s0`i(proc(alpha))")
                      (("2" (case "member(proc(alpha), s0`W(j))")
                        (("1" (lemma card_add)
                          (("1" (inst -1 "s0`W(j)" "proc(alpha)")
                            (("1" (assert -2)
                              (("1"
                                (replace -2 -1)
                                (("1"
                                  (in-fact
                                   "card(s0`W(j)) = 2 + (jj + 1)")
                                  (("1"
                                    (inst ind-hyp j jj+1)
                                    (("1"
                                      (notice ind-hyp)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (lemma card_add)
                          (("2" (assert 1)
                            (("2" (inst -1 "s0`W(j)" "proc(alpha)")
                              (("2"
                                (replace 1 -1)
                                (("2"
                                  (in-fact "card(s0`W(j)) = 2 + jj")
                                  (("2"
                                    (inst ind-hyp j jj)
                                    (("2"
                                      (notice ind-hyp)
                                      (("2"
                                        (case
                                         "s0`victim(j)/=proc(alpha)")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (in-fact
                                           "s0`victim(j) = proc(alpha)")
                                          (("2"
                                            (in-fact
                                             "NOT member(proc(alpha), s0`W(j))")
                                            (("2"
                                              (in-fact
                                               "card(s0`W(j)) >=2")
                                              (("2"
                                                (lemma card_2_has_2)
                                                (("2"
                                                  (inst -1 "s0`W(j)")
                                                  (("2"
                                                    (notice -1)
                                                    (("2"
                                                      (skolem -1 (x y))
                                                      (("2"
                                                        (in-fact
                                                         "x/=proc(alpha)")
                                                        (("2"
                                                          (in-fact
                                                           "y/=proc(alpha)")
                                                          (("2"
                                                            (in-fact
                                                             "member(proc(alpha), s1`W(j))")
                                                            (("2"
                                                              (post-it
                                                               inv_10)
                                                              (("2"
                                                                (post-it
                                                                 inv_10)
                                                                (("2"
                                                                  (post-it
                                                                   inv_10)
                                                                  (("2"
                                                                    (expand
                                                                     "WinnerCharacterization")
                                                                    (("2"
                                                                      (inst
                                                                       -1
                                                                       x
                                                                       j)
                                                                      (("2"
                                                                        (inst
                                                                         -2
                                                                         y
                                                                         j)
                                                                        (("2"
                                                                          (inst
                                                                           -3
                                                                           "proc(alpha)"
                                                                           j)
                                                                          (("2"
                                                                            (in-fact
                                                                             "member(x, s1`W(j))")
                                                                            (("2"
                                                                              (in-fact
                                                                               "member(y, s1`W(j))")
                                                                              (("2"
                                                                                (replace
                                                                                 -2
                                                                                 -3)
                                                                                (("2"
                                                                                  (replace
                                                                                   -1
                                                                                   -4)
                                                                                  (("2"
                                                                                    (hide
                                                                                     (-1
                                                                                      -2))
                                                                                    (("2"
                                                                                      (flatten
                                                                                       (-1
                                                                                        -2))
                                                                                      (("2"
                                                                                        (replace
                                                                                         -4
                                                                                         -3)
                                                                                        (("2"
                                                                                          (flatten
                                                                                           -3)
                                                                                          (("2"
                                                                                            (flatten
                                                                                             -7)
                                                                                            (("2"
                                                                                              (post-it
                                                                                               inv_2)
                                                                                              (("2"
                                                                                                (expand
                                                                                                 "WinnerIsNotVictim")
                                                                                                (("2"
                                                                                                  (inst
                                                                                                   -1
                                                                                                   "proc(alpha)"
                                                                                                   x
                                                                                                   j)
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     "Competitor")
                                                                                                    (("2"
                                                                                                      (notice
                                                                                                       -1)
                                                                                                      (("2"
                                                                                                        (grind)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("4" (flatten concl)
                  (("4" (case "j/=s0`i(proc(alpha))")
                    (("1" (in-fact "card(s0`W(j)) = 2 + (jj + 1)")
                      (("1" (in-fact "card(s0`W(j)) = 2 + (jj + 1)")
                        (("1" (inst ind-hyp j jj+1)
                          (("1" (notice ind-hyp)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (fact "j=s0`i(proc(alpha))")
                      (("2" (fact "s0`victim(j)=s1`victim(j)")
                        (("2"
                          (fact
                           "NOT (s1`victim(s1`i(proc(alpha))) = proc(alpha))")
                          (("2"
                            (in-fact "member(s1`victim(j), s0`W(j))")
                            (("2" (case "member(proc(alpha), s0`W(j))")
                              (("1"
                                (lemma card_add)
                                (("1"
                                  (inst -1 "s0`W(j)" "proc(alpha)")
                                  (("1"
                                    (in-fact
                                     "card(s0`W(j)) = card(s1`W(j))")
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (lemma card_add)
                                (("2"
                                  (inst -1 "s0`W(j)" "proc(alpha)")
                                  (("2"
                                    (assert 1)
                                    (("2"
                                      (replace 1 -1)
                                      (("2"
                                        (in-fact
                                         "card(s0`W(j)) = card(s1`W(j))-1")
                                        (("2"
                                          (in-fact
                                           "card(s0`W(j)) = card(s1`W(j))-1")
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                 ("5" (flatten concl)
                  (("5" (replace eff -3)
                    (("5" (beta -3)
                      (("5" (case "j > 0 AND j <= (s0`i(proc(alpha)))")
                        (("1" (replace -1 -4)
                          (("1" (inv-apply inv_10 s0)
                            (("1" (expand "WinnerCharacterization")
                              (("1"
                                (inst -1 "proc(alpha)" j)
                                (("1"
                                  (case
                                   " NOT Winner(s0, proc(alpha), j)")
                                  (("1"
                                    (replace 1)
                                    (("1"
                                      (flatten inv_10)
                                      (("1"
                                        (assert inv_10)
                                        (("1"
                                          (in-fact
                                           "s0`victim(j)=s1`victim(j)")
                                          (("1"
                                            (lemma card_remove)
                                            (("1"
                                              (inst
                                               -1
                                               "s0`W(j)"
                                               "proc(alpha)")
                                              (("1"
                                                (replace inv_10)
                                                (("1"
                                                  (inst ind-hyp j jj+1)
                                                  (("1"
                                                    (notice ind-hyp)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (replace -1 -2)
                                    (("2"
                                      (flatten inv_10)
                                      (("2"
                                        (in-fact
                                         "s0`victim(j)=s1`victim(j)")
                                        (("2"
                                          (lemma card_remove)
                                          (("2"
                                            (inst
                                             -1
                                             "s0`W(j)"
                                             "proc(alpha)")
                                            (("2"
                                              (assert inv_10)
                                              (("2"
                                                (replace inv_10 -1)
                                                (("2"
                                                  (in-fact
                                                   "card(s0`W(j)) = 2+jj+2")
                                                  (("2"
                                                    (inst
                                                     ind-hyp
                                                     j
                                                     jj+2)
                                                    (("2"
                                                      (notice ind-hyp)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (replace 1 -3)
                          (("2" (inst ind-hyp j jj+1)
                            (("2" (notice ind-hyp)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (lemma_5 formula-decl nil Lemmata nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (reachable? inductive-decl "bool" IOA nil)
    (inv_2 formula-decl nil Lemmata nil)
    (WinnerIsNotVictim const-decl "bool" Lemmata nil)
    (/= const-decl "boolean" notequal nil)
    (Competitor const-decl "bool" Lemmata nil)
    (WinnerCharacterization const-decl "bool" Lemmata nil)
    (inv_10 formula-decl nil Lemmata nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (remove const-decl "set" sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (<= const-decl "bool" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (card_2_has_2 formula-decl nil finite_sets nil)
    (card_add formula-decl nil finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (Winner const-decl "bool" Lemmata nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (empty? const-decl "bool" sets nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (action_lock10_eta formula-decl nil actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (Effect const-decl "cState" FilterLock nil)
    (transition const-decl "bool" IOA nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (action_inclusive formula-decl nil actions nil)
    (proc_inst const-decl "PROC" PROC nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (NotWinner2 const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (inv_5 0
  (inv_5-1 nil 3839570532
   ("" (inv-setup)
    (("1" (assert -1)
      (("1" (conc-rewrite)
        (("1" (assert -1)
          (("1" (expand "FilteredCardinalityInv")
            (("1" (skeep)
              (("1" (inst -1 proc_inst)
                (("1" (flatten)
                  (("1" (inst -6 j)
                    (("1" (case j=0)
                      (("1" (replace -1)
                        (("1" (lemma lemma_6) (("1" (assert) nil nil))
                          nil))
                        nil)
                       ("2" (lemma card_emptyset)
                        (("2" (hide-all-but (-1 -7 1 -8 2))
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (copy-tran)
      (("2" (expand "FilteredCardinalityInv")
        (("2" (with-labels (copy concl) ((concl-cp)))
          (("2" (with-labels (copy ind-hyp) ((ind-hyp-cp)))
            (("2" (skos concl j)
              (("2" (inst ind-hyp j)
                (("2" (for-alpha :lazy? nil)
                  (("1" (delete concl)
                    (("1" (delete ind-hyp)
                      (("1" (with-labels (induct j) ((basis) (concl)))
                        (("1" (inst ind-hyp-cp 0)
                          (("1" (flatten basis)
                            (("1" (notice ind-hyp-cp)
                              (("1"
                                (inv-apply inv_14 s0)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skos concl jj)
                          (("2" (flatten concl)
                            (("2"
                              (case "card(s1`W(jj + 1)) > THREADS - (jj + 1)")
                              (("1"
                                (fact
                                 "card(s1`W(jj + 1)) >= THREADS - jj")
                                (("1"
                                  (notice concl)
                                  (("1"
                                    (label "==>" (-1 -2 -3))
                                    (("1"
                                      (with-labels
                                       (post-it inv_13)
                                       ((inv_13)))
                                      (("1"
                                        (expand "SubsetWs")
                                        (("1"
                                          (inst inv_13 jj)
                                          (("1"
                                            (with-labels
                                             (lemma card_subset)
                                             ((card_subset)))
                                            (("1"
                                              (inst
                                               card_subset
                                               "s1`W(1+jj)"
                                               "s1`W(jj)")
                                              (("1"
                                                (notice card_subset)
                                                (("1"
                                                  (fact
                                                   "card(s1`W(jj + 1)) = card(s1`W(jj))")
                                                  (("1"
                                                    (fact
                                                     "card(s1`W(jj + 1)) = THREADS-jj")
                                                    (("1"
                                                      (fact
                                                       "card(s1`W(jj)) = THREADS-jj")
                                                      (("1"
                                                        (with-labels
                                                         (lemma
                                                          same_card_subset)
                                                         (("same_card")))
                                                        (("1"
                                                          (inst
                                                           same_card
                                                           "s1`W(jj+1)"
                                                           "s1`W(jj)")
                                                          (("1"
                                                            (notice
                                                             same_card)
                                                            (("1"
                                                              (fact
                                                               "card(s1`W(jj + 1))>=2")
                                                              (("1"
                                                                (delete
                                                                 (-5
                                                                  -6
                                                                  -8
                                                                  -9
                                                                  -10))
                                                                (("1"
                                                                  (label
                                                                   "==>"
                                                                   (-1
                                                                    -2
                                                                    -3
                                                                    -4))
                                                                  (("1"
                                                                    (with-labels
                                                                     (lemma
                                                                      card_2_has_2)
                                                                     ((2-elem)))
                                                                    (("1"
                                                                      (inst
                                                                       2-elem
                                                                       "s1`W(jj+1)")
                                                                      (("1"
                                                                        (notice
                                                                         2-elem)
                                                                        (("1"
                                                                          (skeep)
                                                                          (("1"
                                                                            (with-labels
                                                                             (post-it
                                                                              inv_10)
                                                                             ((winn-char)))
                                                                            (("1"
                                                                              (with-labels
                                                                               (post-it
                                                                                inv_10)
                                                                               ((winn-char)))
                                                                              (("1"
                                                                                (expand
                                                                                 "WinnerCharacterization"
                                                                                 winn-char)
                                                                                (("1"
                                                                                  (inst
                                                                                   winn-char
                                                                                   x
                                                                                   jj+1)
                                                                                  (("1"
                                                                                    (inst
                                                                                     winn-char
                                                                                     y
                                                                                     jj+1)
                                                                                    (("1"
                                                                                      (expand
                                                                                       "member"
                                                                                       winn-char)
                                                                                      (("1"
                                                                                        (with-labels
                                                                                         (post-it
                                                                                          inv_3)
                                                                                         (("inv_3")))
                                                                                        (("1"
                                                                                          (expand
                                                                                           Lemma3
                                                                                           inv_3)
                                                                                          (("1"
                                                                                            (inst
                                                                                             inv_3
                                                                                             jj+1)
                                                                                            (("1"
                                                                                              (split
                                                                                               inv_3)
                                                                                              (("1"
                                                                                                (with-labels
                                                                                                 (post-it
                                                                                                  inv_12)
                                                                                                 ((inv_h_w_c)))
                                                                                                (("1"
                                                                                                  (expand
                                                                                                   "HierarchicalWinnerAndComp"
                                                                                                   inv_h_w_c)
                                                                                                  (("1"
                                                                                                    (inst
                                                                                                     inv_h_w_c
                                                                                                     "s1`victim(jj+1)"
                                                                                                     jj)
                                                                                                    (("1"
                                                                                                      (with-labels
                                                                                                       (notice
                                                                                                        inv_h_w_c)
                                                                                                       ((focus)))
                                                                                                      (("1"
                                                                                                        (with-labels
                                                                                                         (post-it
                                                                                                          inv_4)
                                                                                                         ((not-winn)))
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           "NotWinner2"
                                                                                                           not-winn)
                                                                                                          (("1"
                                                                                                            (fact
                                                                                                             "THREADS - 2 - jj >= 0")
                                                                                                            (("1"
                                                                                                              (inst
                                                                                                               not-winn
                                                                                                               jj+1
                                                                                                               "THREADS-2-jj")
                                                                                                              (("1"
                                                                                                                (with-labels
                                                                                                                 (notice
                                                                                                                  not-winn)
                                                                                                                 ((focus)))
                                                                                                                (("1"
                                                                                                                  (with-labels
                                                                                                                   (post-it
                                                                                                                    inv_10)
                                                                                                                   (("winn-c")))
                                                                                                                  (("1"
                                                                                                                    (expand
                                                                                                                     "WinnerCharacterization"
                                                                                                                     winn-c)
                                                                                                                    (("1"
                                                                                                                      (with-labels
                                                                                                                       (inst
                                                                                                                        winn-c
                                                                                                                        "s1`victim(jj+1)"
                                                                                                                        jj)
                                                                                                                       ((focus)))
                                                                                                                      (("1"
                                                                                                                        (with-labels
                                                                                                                         (in-fact
                                                                                                                          "NOT member(s1`victim(jj + 1), s1`W(jj))")
                                                                                                                         ((focus)))
                                                                                                                        (("1"
                                                                                                                          (hide-all-but
                                                                                                                           focus)
                                                                                                                          (("1"
                                                                                                                            (assert)
                                                                                                                            nil
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil)
                                                                                               ("2"
                                                                                                (inst
                                                                                                 inv_3
                                                                                                 x)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   "Competitor"
                                                                                                   inv_3)
                                                                                                  (("2"
                                                                                                    (grind)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but +)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                   ("2" (delete concl)
                    (("2" (delete ind-hyp)
                      (("2" (with-labels (induct j) ((basis) (concl)))
                        (("1" (inst ind-hyp-cp 0)
                          (("1" (flatten basis)
                            (("1" (notice ind-hyp-cp)
                              (("1"
                                (inv-apply inv_14 s0)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skos concl jj)
                          (("2" (flatten concl)
                            (("2"
                              (case "card(s1`W(jj + 1)) > THREADS - (jj + 1)")
                              (("1"
                                (fact
                                 "card(s1`W(jj + 1)) >= THREADS - jj")
                                (("1"
                                  (notice concl)
                                  (("1"
                                    (label "==>" (-1 -2 -3))
                                    (("1"
                                      (with-labels
                                       (lemma inv_13)
                                       ((inv_13)))
                                      (("1"
                                        (expand "invariant")
                                        (("1"
                                          (inst inv_13 s1)
                                          (("1"
                                            (reach-it inv_13)
                                            (("1"
                                              (expand "SubsetWs")
                                              (("1"
                                                (inst conseq jj)
                                                (("1"
                                                  (with-labels
                                                   (lemma card_subset)
                                                   ((card_subset)))
                                                  (("1"
                                                    (inst
                                                     card_subset
                                                     "s1`W(1+jj)"
                                                     "s1`W(jj)")
                                                    (("1"
                                                      (notice
                                                       card_subset)
                                                      (("1"
                                                        (fact
                                                         "card(s1`W(jj + 1)) = card(s1`W(jj))")
                                                        (("1"
                                                          (fact
                                                           "card(s1`W(jj + 1)) = THREADS-jj")
                                                          (("1"
                                                            (fact
                                                             "card(s1`W(jj)) = THREADS-jj")
                                                            (("1"
                                                              (with-labels
                                                               (lemma
                                                                same_card_subset)
                                                               (("same_card")))
                                                              (("1"
                                                                (inst
                                                                 same_card
                                                                 "s1`W(jj+1)"
                                                                 "s1`W(jj)")
                                                                (("1"
                                                                  (notice
                                                                   same_card)
                                                                  (("1"
                                                                    (fact
                                                                     "card(s1`W(jj + 1))>=2")
                                                                    (("1"
                                                                      (delete
                                                                       (-5
                                                                        -6
                                                                        -8
                                                                        -9
                                                                        -10))
                                                                      (("1"
                                                                        (label
                                                                         "==>"
                                                                         (-1
                                                                          -2
                                                                          -3
                                                                          -4))
                                                                        (("1"
                                                                          (with-labels
                                                                           (lemma
                                                                            card_2_has_2)
                                                                           ((2-elem)))
                                                                          (("1"
                                                                            (inst
                                                                             2-elem
                                                                             "s1`W(jj+1)")
                                                                            (("1"
                                                                              (notice
                                                                               2-elem)
                                                                              (("1"
                                                                                (skeep)
                                                                                (("1"
                                                                                  (with-labels
                                                                                   (lemma
                                                                                    inv_10)
                                                                                   ((winn-char)))
                                                                                  (("1"
                                                                                    (with-labels
                                                                                     (lemma
                                                                                      inv_10)
                                                                                     ((winn-char)))
                                                                                    (("1"
                                                                                      (expand
                                                                                       "invariant"
                                                                                       winn-char)
                                                                                      (("1"
                                                                                        (inst
                                                                                         winn-char
                                                                                         s1)
                                                                                        (("1"
                                                                                          (inst?)
                                                                                          (("1"
                                                                                            (reach-it
                                                                                             winn-char)
                                                                                            (("1"
                                                                                              (reach-it
                                                                                               winn-char)
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "WinnerCharacterization"
                                                                                                 conseq)
                                                                                                (("1"
                                                                                                  (inst
                                                                                                   conseq
                                                                                                   x
                                                                                                   jj+1)
                                                                                                  (("1"
                                                                                                    (inst
                                                                                                     conseq
                                                                                                     y
                                                                                                     jj+1)
                                                                                                    (("1"
                                                                                                      (expand
                                                                                                       "member"
                                                                                                       conseq)
                                                                                                      (("1"
                                                                                                        (with-labels
                                                                                                         (lemma
                                                                                                          inv_3)
                                                                                                         (("inv_3")))
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           invariant
                                                                                                           inv_3)
                                                                                                          (("1"
                                                                                                            (inst
                                                                                                             inv_3
                                                                                                             s1)
                                                                                                            (("1"
                                                                                                              (reach-it
                                                                                                               inv_3)
                                                                                                              (("1"
                                                                                                                (expand
                                                                                                                 Lemma3
                                                                                                                 conseq)
                                                                                                                (("1"
                                                                                                                  (inst
                                                                                                                   conseq
                                                                                                                   jj+1)
                                                                                                                  (("1"
                                                                                                                    (split
                                                                                                                     conseq)
                                                                                                                    (("1"
                                                                                                                      (with-labels
                                                                                                                       (lemma
                                                                                                                        inv_12)
                                                                                                                       ((inv_h_w_c)))
                                                                                                                      (("1"
                                                                                                                        (expand
                                                                                                                         invariant
                                                                                                                         inv_h_w_c)
                                                                                                                        (("1"
                                                                                                                          (inst
                                                                                                                           inv_h_w_c
                                                                                                                           s1)
                                                                                                                          (("1"
                                                                                                                            (reach-it
                                                                                                                             inv_h_w_c)
                                                                                                                            (("1"
                                                                                                                              (expand
                                                                                                                               "HierarchicalWinnerAndComp"
                                                                                                                               conseq)
                                                                                                                              (("1"
                                                                                                                                (inst
                                                                                                                                 conseq
                                                                                                                                 "s1`victim(jj+1)"
                                                                                                                                 jj)
                                                                                                                                (("1"
                                                                                                                                  (with-labels
                                                                                                                                   (notice
                                                                                                                                    conseq)
                                                                                                                                   ((focus)))
                                                                                                                                  (("1"
                                                                                                                                    (with-labels
                                                                                                                                     (lemma
                                                                                                                                      inv_4)
                                                                                                                                     ((not-winn)))
                                                                                                                                    (("1"
                                                                                                                                      (expand
                                                                                                                                       invariant
                                                                                                                                       not-winn)
                                                                                                                                      (("1"
                                                                                                                                        (inst
                                                                                                                                         not-winn
                                                                                                                                         s1)
                                                                                                                                        (("1"
                                                                                                                                          (reach-it
                                                                                                                                           not-winn)
                                                                                                                                          (("1"
                                                                                                                                            (expand
                                                                                                                                             "NotWinner2"
                                                                                                                                             conseq)
                                                                                                                                            (("1"
                                                                                                                                              (fact
                                                                                                                                               "THREADS - 2 - jj >= 0")
                                                                                                                                              (("1"
                                                                                                                                                (inst
                                                                                                                                                 conseq
                                                                                                                                                 jj+1
                                                                                                                                                 "THREADS-2-jj")
                                                                                                                                                (("1"
                                                                                                                                                  (with-labels
                                                                                                                                                   (notice
                                                                                                                                                    conseq)
                                                                                                                                                   ((focus)))
                                                                                                                                                  (("1"
                                                                                                                                                    (with-labels
                                                                                                                                                     (lemma
                                                                                                                                                      inv_10)
                                                                                                                                                     (("winn-c")))
                                                                                                                                                    (("1"
                                                                                                                                                      (expand
                                                                                                                                                       invariant
                                                                                                                                                       winn-c)
                                                                                                                                                      (("1"
                                                                                                                                                        (inst
                                                                                                                                                         winn-c
                                                                                                                                                         s1)
                                                                                                                                                        (("1"
                                                                                                                                                          (reach-it
                                                                                                                                                           winn-c)
                                                                                                                                                          (("1"
                                                                                                                                                            (expand
                                                                                                                                                             "WinnerCharacterization"
                                                                                                                                                             conseq)
                                                                                                                                                            (("1"
                                                                                                                                                              (with-labels
                                                                                                                                                               (inst
                                                                                                                                                                conseq
                                                                                                                                                                "s1`victim(jj+1)"
                                                                                                                                                                jj)
                                                                                                                                                               ((focus)))
                                                                                                                                                              (("1"
                                                                                                                                                                (with-labels
                                                                                                                                                                 (in-fact
                                                                                                                                                                  "NOT member(s1`victim(jj + 1), s1`W(jj))")
                                                                                                                                                                 ((focus)))
                                                                                                                                                                (("1"
                                                                                                                                                                  (hide-all-but
                                                                                                                                                                   focus)
                                                                                                                                                                  (("1"
                                                                                                                                                                    (assert)
                                                                                                                                                                    nil
                                                                                                                                                                    nil))
                                                                                                                                                                  nil))
                                                                                                                                                                nil))
                                                                                                                                                              nil))
                                                                                                                                                            nil))
                                                                                                                                                          nil))
                                                                                                                                                        nil))
                                                                                                                                                      nil))
                                                                                                                                                    nil))
                                                                                                                                                  nil))
                                                                                                                                                nil))
                                                                                                                                              nil))
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil)
                                                                                                                     ("2"
                                                                                                                      (inst
                                                                                                                       conseq
                                                                                                                       x)
                                                                                                                      (("2"
                                                                                                                        (expand
                                                                                                                         "Competitor"
                                                                                                                         conseq)
                                                                                                                        (("2"
                                                                                                                          (grind)
                                                                                                                          nil
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but +)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                   ("3" (delete concl)
                    (("3" (delete ind-hyp)
                      (("3" (with-labels (induct j) ((basis) (concl)))
                        (("1" (inst ind-hyp-cp 0)
                          (("1" (flatten basis)
                            (("1" (notice ind-hyp-cp)
                              (("1"
                                (inv-apply inv_14 s0)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skos concl jj)
                          (("2" (flatten concl)
                            (("2"
                              (case "card(s1`W(jj + 1)) > THREADS - (jj + 1)")
                              (("1"
                                (fact
                                 "card(s1`W(jj + 1)) >= THREADS - jj")
                                (("1"
                                  (notice concl)
                                  (("1"
                                    (label "==>" (-1 -2 -3))
                                    (("1"
                                      (with-labels
                                       (lemma inv_13)
                                       ((inv_13)))
                                      (("1"
                                        (expand "invariant")
                                        (("1"
                                          (inst inv_13 s1)
                                          (("1"
                                            (reach-it inv_13)
                                            (("1"
                                              (expand "SubsetWs")
                                              (("1"
                                                (inst conseq jj)
                                                (("1"
                                                  (with-labels
                                                   (lemma card_subset)
                                                   ((card_subset)))
                                                  (("1"
                                                    (inst
                                                     card_subset
                                                     "s1`W(1+jj)"
                                                     "s1`W(jj)")
                                                    (("1"
                                                      (notice
                                                       card_subset)
                                                      (("1"
                                                        (fact
                                                         "card(s1`W(jj + 1)) = card(s1`W(jj))")
                                                        (("1"
                                                          (fact
                                                           "card(s1`W(jj + 1)) = THREADS-jj")
                                                          (("1"
                                                            (fact
                                                             "card(s1`W(jj)) = THREADS-jj")
                                                            (("1"
                                                              (with-labels
                                                               (lemma
                                                                same_card_subset)
                                                               (("same_card")))
                                                              (("1"
                                                                (inst
                                                                 same_card
                                                                 "s1`W(jj+1)"
                                                                 "s1`W(jj)")
                                                                (("1"
                                                                  (notice
                                                                   same_card)
                                                                  (("1"
                                                                    (fact
                                                                     "card(s1`W(jj + 1))>=2")
                                                                    (("1"
                                                                      (delete
                                                                       (-5
                                                                        -6
                                                                        -8
                                                                        -9
                                                                        -10))
                                                                      (("1"
                                                                        (label
                                                                         "==>"
                                                                         (-1
                                                                          -2
                                                                          -3
                                                                          -4))
                                                                        (("1"
                                                                          (with-labels
                                                                           (lemma
                                                                            card_2_has_2)
                                                                           ((2-elem)))
                                                                          (("1"
                                                                            (inst
                                                                             2-elem
                                                                             "s1`W(jj+1)")
                                                                            (("1"
                                                                              (notice
                                                                               2-elem)
                                                                              (("1"
                                                                                (skeep)
                                                                                (("1"
                                                                                  (with-labels
                                                                                   (lemma
                                                                                    inv_10)
                                                                                   ((winn-char)))
                                                                                  (("1"
                                                                                    (with-labels
                                                                                     (lemma
                                                                                      inv_10)
                                                                                     ((winn-char)))
                                                                                    (("1"
                                                                                      (expand
                                                                                       "invariant"
                                                                                       winn-char)
                                                                                      (("1"
                                                                                        (inst
                                                                                         winn-char
                                                                                         s1)
                                                                                        (("1"
                                                                                          (inst?)
                                                                                          (("1"
                                                                                            (reach-it
                                                                                             winn-char)
                                                                                            (("1"
                                                                                              (reach-it
                                                                                               winn-char)
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "WinnerCharacterization"
                                                                                                 conseq)
                                                                                                (("1"
                                                                                                  (inst
                                                                                                   conseq
                                                                                                   x
                                                                                                   jj+1)
                                                                                                  (("1"
                                                                                                    (inst
                                                                                                     conseq
                                                                                                     y
                                                                                                     jj+1)
                                                                                                    (("1"
                                                                                                      (expand
                                                                                                       "member"
                                                                                                       conseq)
                                                                                                      (("1"
                                                                                                        (with-labels
                                                                                                         (lemma
                                                                                                          inv_3)
                                                                                                         (("inv_3")))
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           invariant
                                                                                                           inv_3)
                                                                                                          (("1"
                                                                                                            (inst
                                                                                                             inv_3
                                                                                                             s1)
                                                                                                            (("1"
                                                                                                              (reach-it
                                                                                                               inv_3)
                                                                                                              (("1"
                                                                                                                (expand
                                                                                                                 Lemma3
                                                                                                                 conseq)
                                                                                                                (("1"
                                                                                                                  (inst
                                                                                                                   conseq
                                                                                                                   jj+1)
                                                                                                                  (("1"
                                                                                                                    (split
                                                                                                                     conseq)
                                                                                                                    (("1"
                                                                                                                      (with-labels
                                                                                                                       (lemma
                                                                                                                        inv_12)
                                                                                                                       ((inv_h_w_c)))
                                                                                                                      (("1"
                                                                                                                        (expand
                                                                                                                         invariant
                                                                                                                         inv_h_w_c)
                                                                                                                        (("1"
                                                                                                                          (inst
                                                                                                                           inv_h_w_c
                                                                                                                           s1)
                                                                                                                          (("1"
                                                                                                                            (reach-it
                                                                                                                             inv_h_w_c)
                                                                                                                            (("1"
                                                                                                                              (expand
                                                                                                                               "HierarchicalWinnerAndComp"
                                                                                                                               conseq)
                                                                                                                              (("1"
                                                                                                                                (inst
                                                                                                                                 conseq
                                                                                                                                 "s1`victim(jj+1)"
                                                                                                                                 jj)
                                                                                                                                (("1"
                                                                                                                                  (with-labels
                                                                                                                                   (notice
                                                                                                                                    conseq)
                                                                                                                                   ((focus)))
                                                                                                                                  (("1"
                                                                                                                                    (with-labels
                                                                                                                                     (lemma
                                                                                                                                      inv_4)
                                                                                                                                     ((not-winn)))
                                                                                                                                    (("1"
                                                                                                                                      (expand
                                                                                                                                       invariant
                                                                                                                                       not-winn)
                                                                                                                                      (("1"
                                                                                                                                        (inst
                                                                                                                                         not-winn
                                                                                                                                         s1)
                                                                                                                                        (("1"
                                                                                                                                          (reach-it
                                                                                                                                           not-winn)
                                                                                                                                          (("1"
                                                                                                                                            (expand
                                                                                                                                             "NotWinner2"
                                                                                                                                             conseq)
                                                                                                                                            (("1"
                                                                                                                                              (fact
                                                                                                                                               "THREADS - 2 - jj >= 0")
                                                                                                                                              (("1"
                                                                                                                                                (inst
                                                                                                                                                 conseq
                                                                                                                                                 jj+1
                                                                                                                                                 "THREADS-2-jj")
                                                                                                                                                (("1"
                                                                                                                                                  (with-labels
                                                                                                                                                   (notice
                                                                                                                                                    conseq)
                                                                                                                                                   ((focus)))
                                                                                                                                                  (("1"
                                                                                                                                                    (with-labels
                                                                                                                                                     (lemma
                                                                                                                                                      inv_10)
                                                                                                                                                     (("winn-c")))
                                                                                                                                                    (("1"
                                                                                                                                                      (expand
                                                                                                                                                       invariant
                                                                                                                                                       winn-c)
                                                                                                                                                      (("1"
                                                                                                                                                        (inst
                                                                                                                                                         winn-c
                                                                                                                                                         s1)
                                                                                                                                                        (("1"
                                                                                                                                                          (reach-it
                                                                                                                                                           winn-c)
                                                                                                                                                          (("1"
                                                                                                                                                            (expand
                                                                                                                                                             "WinnerCharacterization"
                                                                                                                                                             conseq)
                                                                                                                                                            (("1"
                                                                                                                                                              (with-labels
                                                                                                                                                               (inst
                                                                                                                                                                conseq
                                                                                                                                                                "s1`victim(jj+1)"
                                                                                                                                                                jj)
                                                                                                                                                               ((focus)))
                                                                                                                                                              (("1"
                                                                                                                                                                (with-labels
                                                                                                                                                                 (in-fact
                                                                                                                                                                  "NOT member(s1`victim(jj + 1), s1`W(jj))")
                                                                                                                                                                 ((focus)))
                                                                                                                                                                (("1"
                                                                                                                                                                  (hide-all-but
                                                                                                                                                                   focus)
                                                                                                                                                                  (("1"
                                                                                                                                                                    (assert)
                                                                                                                                                                    nil
                                                                                                                                                                    nil))
                                                                                                                                                                  nil))
                                                                                                                                                                nil))
                                                                                                                                                              nil))
                                                                                                                                                            nil))
                                                                                                                                                          nil))
                                                                                                                                                        nil))
                                                                                                                                                      nil))
                                                                                                                                                    nil))
                                                                                                                                                  nil))
                                                                                                                                                nil))
                                                                                                                                              nil))
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil)
                                                                                                                     ("2"
                                                                                                                      (inst
                                                                                                                       conseq
                                                                                                                       x)
                                                                                                                      (("2"
                                                                                                                        (expand
                                                                                                                         "Competitor"
                                                                                                                         conseq)
                                                                                                                        (("2"
                                                                                                                          (grind)
                                                                                                                          nil
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but +)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    ";;; Ready to prove this case: transition is expanded w.r.t. alpha")
                   ("4" (delete concl)
                    (("4" (delete ind-hyp)
                      (("4" (with-labels (induct j) ((basis) (concl)))
                        (("1" (inst ind-hyp-cp 0)
                          (("1" (flatten basis)
                            (("1" (notice ind-hyp-cp)
                              (("1"
                                (inv-apply inv_14 s0)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skos concl jj)
                          (("2" (flatten concl)
                            (("2"
                              (case "card(s1`W(jj + 1)) > THREADS - (jj + 1)")
                              (("1"
                                (fact
                                 "card(s1`W(jj + 1)) >= THREADS - jj")
                                (("1"
                                  (notice concl)
                                  (("1"
                                    (label "==>" (-1 -2 -3))
                                    (("1"
                                      (with-labels
                                       (lemma inv_13)
                                       ((inv_13)))
                                      (("1"
                                        (expand "invariant")
                                        (("1"
                                          (inst inv_13 s1)
                                          (("1"
                                            (reach-it inv_13)
                                            (("1"
                                              (expand "SubsetWs")
                                              (("1"
                                                (inst conseq jj)
                                                (("1"
                                                  (with-labels
                                                   (lemma card_subset)
                                                   ((card_subset)))
                                                  (("1"
                                                    (inst
                                                     card_subset
                                                     "s1`W(1+jj)"
                                                     "s1`W(jj)")
                                                    (("1"
                                                      (notice
                                                       card_subset)
                                                      (("1"
                                                        (fact
                                                         "card(s1`W(jj + 1)) = card(s1`W(jj))")
                                                        (("1"
                                                          (fact
                                                           "card(s1`W(jj + 1)) = THREADS-jj")
                                                          (("1"
                                                            (fact
                                                             "card(s1`W(jj)) = THREADS-jj")
                                                            (("1"
                                                              (with-labels
                                                               (lemma
                                                                same_card_subset)
                                                               (("same_card")))
                                                              (("1"
                                                                (inst
                                                                 same_card
                                                                 "s1`W(jj+1)"
                                                                 "s1`W(jj)")
                                                                (("1"
                                                                  (notice
                                                                   same_card)
                                                                  (("1"
                                                                    (fact
                                                                     "card(s1`W(jj + 1))>=2")
                                                                    (("1"
                                                                      (delete
                                                                       (-5
                                                                        -6
                                                                        -8
                                                                        -9
                                                                        -10))
                                                                      (("1"
                                                                        (label
                                                                         "==>"
                                                                         (-1
                                                                          -2
                                                                          -3
                                                                          -4))
                                                                        (("1"
                                                                          (with-labels
                                                                           (lemma
                                                                            card_2_has_2)
                                                                           ((2-elem)))
                                                                          (("1"
                                                                            (inst
                                                                             2-elem
                                                                             "s1`W(jj+1)")
                                                                            (("1"
                                                                              (notice
                                                                               2-elem)
                                                                              (("1"
                                                                                (skeep)
                                                                                (("1"
                                                                                  (with-labels
                                                                                   (lemma
                                                                                    inv_10)
                                                                                   ((winn-char)))
                                                                                  (("1"
                                                                                    (with-labels
                                                                                     (lemma
                                                                                      inv_10)
                                                                                     ((winn-char)))
                                                                                    (("1"
                                                                                      (expand
                                                                                       "invariant"
                                                                                       winn-char)
                                                                                      (("1"
                                                                                        (inst
                                                                                         winn-char
                                                                                         s1)
                                                                                        (("1"
                                                                                          (inst?)
                                                                                          (("1"
                                                                                            (reach-it
                                                                                             winn-char)
                                                                                            (("1"
                                                                                              (reach-it
                                                                                               winn-char)
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "WinnerCharacterization"
                                                                                                 conseq)
                                                                                                (("1"
                                                                                                  (inst
                                                                                                   conseq
                                                                                                   x
                                                                                                   jj+1)
                                                                                                  (("1"
                                                                                                    (inst
                                                                                                     conseq
                                                                                                     y
                                                                                                     jj+1)
                                                                                                    (("1"
                                                                                                      (expand
                                                                                                       "member"
                                                                                                       conseq)
                                                                                                      (("1"
                                                                                                        (with-labels
                                                                                                         (lemma
                                                                                                          inv_3)
                                                                                                         (("inv_3")))
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           invariant
                                                                                                           inv_3)
                                                                                                          (("1"
                                                                                                            (inst
                                                                                                             inv_3
                                                                                                             s1)
                                                                                                            (("1"
                                                                                                              (reach-it
                                                                                                               inv_3)
                                                                                                              (("1"
                                                                                                                (expand
                                                                                                                 Lemma3
                                                                                                                 conseq)
                                                                                                                (("1"
                                                                                                                  (inst
                                                                                                                   conseq
                                                                                                                   jj+1)
                                                                                                                  (("1"
                                                                                                                    (split
                                                                                                                     conseq)
                                                                                                                    (("1"
                                                                                                                      (with-labels
                                                                                                                       (lemma
                                                                                                                        inv_12)
                                                                                                                       ((inv_h_w_c)))
                                                                                                                      (("1"
                                                                                                                        (expand
                                                                                                                         invariant
                                                                                                                         inv_h_w_c)
                                                                                                                        (("1"
                                                                                                                          (inst
                                                                                                                           inv_h_w_c
                                                                                                                           s1)
                                                                                                                          (("1"
                                                                                                                            (reach-it
                                                                                                                             inv_h_w_c)
                                                                                                                            (("1"
                                                                                                                              (expand
                                                                                                                               "HierarchicalWinnerAndComp"
                                                                                                                               conseq)
                                                                                                                              (("1"
                                                                                                                                (inst
                                                                                                                                 conseq
                                                                                                                                 "s1`victim(jj+1)"
                                                                                                                                 jj)
                                                                                                                                (("1"
                                                                                                                                  (with-labels
                                                                                                                                   (notice
                                                                                                                                    conseq)
                                                                                                                                   ((focus)))
                                                                                                                                  (("1"
                                                                                                                                    (with-labels
                                                                                                                                     (lemma
                                                                                                                                      inv_4)
                                                                                                                                     ((not-winn)))
                                                                                                                                    (("1"
                                                                                                                                      (expand
                                                                                                                                       invariant
                                                                                                                                       not-winn)
                                                                                                                                      (("1"
                                                                                                                                        (inst
                                                                                                                                         not-winn
                                                                                                                                         s1)
                                                                                                                                        (("1"
                                                                                                                                          (reach-it
                                                                                                                                           not-winn)
                                                                                                                                          (("1"
                                                                                                                                            (expand
                                                                                                                                             "NotWinner2"
                                                                                                                                             conseq)
                                                                                                                                            (("1"
                                                                                                                                              (fact
                                                                                                                                               "THREADS - 2 - jj >= 0")
                                                                                                                                              (("1"
                                                                                                                                                (inst
                                                                                                                                                 conseq
                                                                                                                                                 jj+1
                                                                                                                                                 "THREADS-2-jj")
                                                                                                                                                (("1"
                                                                                                                                                  (with-labels
                                                                                                                                                   (notice
                                                                                                                                                    conseq)
                                                                                                                                                   ((focus)))
                                                                                                                                                  (("1"
                                                                                                                                                    (with-labels
                                                                                                                                                     (lemma
                                                                                                                                                      inv_10)
                                                                                                                                                     (("winn-c")))
                                                                                                                                                    (("1"
                                                                                                                                                      (expand
                                                                                                                                                       invariant
                                                                                                                                                       winn-c)
                                                                                                                                                      (("1"
                                                                                                                                                        (inst
                                                                                                                                                         winn-c
                                                                                                                                                         s1)
                                                                                                                                                        (("1"
                                                                                                                                                          (reach-it
                                                                                                                                                           winn-c)
                                                                                                                                                          (("1"
                                                                                                                                                            (expand
                                                                                                                                                             "WinnerCharacterization"
                                                                                                                                                             conseq)
                                                                                                                                                            (("1"
                                                                                                                                                              (with-labels
                                                                                                                                                               (inst
                                                                                                                                                                conseq
                                                                                                                                                                "s1`victim(jj+1)"
                                                                                                                                                                jj)
                                                                                                                                                               ((focus)))
                                                                                                                                                              (("1"
                                                                                                                                                                (with-labels
                                                                                                                                                                 (in-fact
                                                                                                                                                                  "NOT member(s1`victim(jj + 1), s1`W(jj))")
                                                                                                                                                                 ((focus)))
                                                                                                                                                                (("1"
                                                                                                                                                                  (hide-all-but
                                                                                                                                                                   focus)
                                                                                                                                                                  (("1"
                                                                                                                                                                    (assert)
                                                                                                                                                                    nil
                                                                                                                                                                    nil))
                                                                                                                                                                  nil))
                                                                                                                                                                nil))
                                                                                                                                                              nil))
                                                                                                                                                            nil))
                                                                                                                                                          nil))
                                                                                                                                                        nil))
                                                                                                                                                      nil))
                                                                                                                                                    nil))
                                                                                                                                                  nil))
                                                                                                                                                nil))
                                                                                                                                              nil))
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil)
                                                                                                                     ("2"
                                                                                                                      (inst
                                                                                                                       conseq
                                                                                                                       x)
                                                                                                                      (("2"
                                                                                                                        (expand
                                                                                                                         "Competitor"
                                                                                                                         conseq)
                                                                                                                        (("2"
                                                                                                                          (grind)
                                                                                                                          nil
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but +)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_lock10_eta formula-decl nil actions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (member const-decl "bool" sets nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (reachable? inductive-decl "bool" IOA nil)
    (inv_13 formula-decl nil Lemmata nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (Lemma3 const-decl "bool" Lemmata nil)
    (HierarchicalWinnerAndComp const-decl "bool" Lemmata nil)
    (Competitor const-decl "bool" Lemmata nil)
    (CheckVictim const-decl "bool" Lemmata nil)
    (CheckFlag const-decl "bool" Lemmata nil)
    (Winner const-decl "bool" Lemmata nil)
    (NotWinner2 const-decl "bool" Lemmata nil)
    (jj skolem-const-decl "nat" Lemmata nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (inv_4 formula-decl nil Lemmata nil)
    (inv_12 formula-decl nil Lemmata nil)
    (inv_3 formula-decl nil Lemmata nil)
    (WinnerCharacterization const-decl "bool" Lemmata nil)
    (inv_10 formula-decl nil Lemmata nil)
    (card_2_has_2 formula-decl nil finite_sets nil)
    (subset? const-decl "bool" sets nil)
    (same_card_subset formula-decl nil finite_sets nil)
    (card_subset formula-decl nil finite_sets nil)
    (SubsetWs const-decl "bool" Lemmata nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (PositiveI const-decl "bool" Lemmata nil)
    (inv_14 formula-decl nil Lemmata nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (jj skolem-const-decl "nat" Lemmata nil)
    (jj skolem-const-decl "nat" Lemmata nil)
    (jj skolem-const-decl "nat" Lemmata nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (lemma_6 formula-decl nil Lemmata nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_emptyset formula-decl nil finite_sets nil)
    (proc_inst const-decl "PROC" PROC nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (FilteredCardinalityInv const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak))
 (AloneInCS_TCC1 0
  (AloneInCS_TCC1-1 nil 3845204205 ("" (subtype-tcc) nil nil) nil nil
   (AloneInCS subtype "(number_fields.-)(PROC.THREADS, 1)" "nat")))
 (inv_6 0
  (inv_6-1 nil 3839586891
   ("" (inv-setup)
    (("1" (conc-rewrite)
      (("1" (assert -1)
        (("1" (expand "AloneInCS")
          (("1" (skeep) (("1" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (expand "AloneInCS")
      (("2" (skos concl p)
        (("2" (inst ind-hyp p)
          (("2" (case "proc(alpha)=p")
            (("1" (for-alpha :lazy? nil)
              (("1" (flatten concl)
                (("1" (split -6)
                  (("1" (grind) nil nil)
                   ("2" (inv-apply inv_10 s0)
                    (("2" (expand "WinnerCharacterization")
                      (("2" (inst -1 p THREADS-1)
                        (("2" (in-fact "Winner(s0, p, THREADS-1)")
                          (("2" (replace -1 -2)
                            (("2" (flatten -2) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                ";;; Ready to prove this case: transition is expanded w.r.t. alpha"))
              nil)
             ("2" (for-alpha :lazy? nil) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (remove const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (action_inclusive formula-decl nil actions nil)
    (transition const-decl "bool" IOA nil)
    (Effect const-decl "cState" FilterLock nil)
    (PcEff const-decl "PCs" FilterLock nil)
    (LogicEff const-decl "cState" FilterLock nil)
    (Precondition const-decl "bool" FilterLock nil)
    (PcPrec const-decl "PCs" FilterLock nil)
    (LogicPrec const-decl "bool" FilterLock nil)
    (unlock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (alpha skolem-const-decl "action?" Lemmata nil)
    (action_unlock1_eta formula-decl nil actions nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[PROC]" FilterLock nil)
    (lock9F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9F_eta formula-decl nil actions nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[PROC]" FilterLock nil)
    (lock9T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock9T_eta formula-decl nil actions nil)
    (lock8F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8F_eta formula-decl nil actions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lock8T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock8T_eta formula-decl nil actions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lock7F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7F_eta formula-decl nil actions nil)
    (finite_remove application-judgement "finite_set[PROC]" FilterLock
     nil)
    (lock7T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock7T_eta formula-decl nil actions nil)
    (empty? const-decl "bool" sets nil)
    (lock6F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6F_eta formula-decl nil actions nil)
    (lock6T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock6T_eta formula-decl nil actions nil)
    (lock5? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock5_eta formula-decl nil actions nil)
    (lock4? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock4_eta formula-decl nil actions nil)
    (lock3? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock3_eta formula-decl nil actions nil)
    (lock2F? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2F_eta formula-decl nil actions nil)
    (lock2T? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock2T_eta formula-decl nil actions nil)
    (lock1? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock1_eta formula-decl nil actions nil)
    (LockRet? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockRet_eta formula-decl nil actions nil)
    (LockInv? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_LockInv_eta formula-decl nil actions nil)
    (lock10? adt-recognizer-decl "[action -> boolean]" actions nil)
    (action_lock10_eta formula-decl nil actions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (WinnerCharacterization const-decl "bool" Lemmata nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Winner const-decl "bool" Lemmata nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (inv_10 formula-decl nil Lemmata nil)
    (proc shared-adt-accessor-decl "[action -> PROC]" actions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (InitialStatePredicate const-decl "bool" FilterLock nil)
    (reachable?_induction formula-decl nil IOA nil)
    (IOA type-eq-decl nil IOA nil)
    (CO_IOA type-eq-decl nil FilterLock nil)
    (co_ioa_inst const-decl "CO_IOA" FilterLock nil)
    (AloneInCS const-decl "bool" Lemmata nil)
    (PROC nonempty-type-eq-decl nil PROC nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (THREADS const-decl "above(1)" PROC nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PCs type-decl nil FilterLock nil)
    (cState type-eq-decl nil FilterLock nil)
    (action type-decl nil actions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (external adt-def-decl "boolean" actions nil)
    (internal adt-def-decl "boolean" actions nil)
    (action? nonempty-type-eq-decl nil actions nil)
    (invariant const-decl "bool" invariant nil))
   shostak)))

